# Integrals_eig_bruteforce.py
# Eigenvalue computation for matrices generated by Iee_matrix_bruteforce_generate.py
import os
import glob
import numpy as np
import pickle
import math
from scipy.sparse import csr_matrix
from matplotlib import pyplot as plt

# Configuration
ms = [0, 1, 2, 3, 4, 5]
k = 0  # Figure-1 style (no "-a2" files)

plt.rcParams['text.usetex'] = False
plt.rcParams['font.family'] = 'serif'
plt.rcParams["legend.frameon"] = False

# Directory where bruteforce matrices are stored
MATRIX_DIR = "Matrixes_bruteforce"


def _theta_str(theta: float) -> str:
    """Format theta for filename matching."""
    return f"{theta:.10g}"


def Fourier_transform2(func, th_i, dV_th, m):
    """Fourier transform for angular mode m."""
    exp = np.cos(th_i * m)
    integ = func * exp
    return np.sum(integ)


def build_centered_lattice(Nmax: int):
    """Build centered momentum lattice indices (same as in generator)."""
    half = Nmax // 2
    ns = np.arange(-half, half, dtype=np.int32)
    nx, ny = np.meshgrid(ns, ns, indexing="ij")
    nx = nx.reshape(-1)
    ny = ny.reshape(-1)
    return nx, ny, half


def reconstruct_momentum_grid(meta):
    """
    Reconstruct momentum grid for active states from metadata.
    Returns: p_i (magnitude), th_i (angle), dV_p (radial measure), dV_th (angular measure)
    """
    Nmax = int(meta["Nmax"])
    dp = float(meta["dp"])
    half = int(meta["half"])
    shift_x = float(meta.get("shift_x", 0.0))
    shift_y = float(meta.get("shift_y", 0.0))
    active = meta["active"].astype(np.int32)
    
    # Reconstruct full lattice
    nx_full, ny_full, _ = build_centered_lattice(Nmax)
    
    # Get active states
    nx_active = nx_full[active]
    ny_active = ny_full[active]
    
    # Compute physical momenta
    px = dp * (nx_active.astype(np.float64) + shift_x)
    py = dp * (ny_active.astype(np.float64) + shift_y)
    p_i = np.sqrt(px * px + py * py)
    th_i = np.arctan2(py, px)  # angle in [-pi, pi]
    
    # Radial measure: dp^2 for 2D (area element in momentum space)
    dV_p = dp * dp
    
    # Angular measure: need to bin angles
    # For each unique angle (or small bins), compute dV_th
    # Simple approach: use uniform angular bins
    # More accurate: group by similar angles and compute bin widths
    n_theta_bins = 200  # number of angular bins
    th_bins = np.linspace(-np.pi, np.pi, n_theta_bins + 1)
    th_centers = 0.5 * (th_bins[:-1] + th_bins[1:])
    
    # Count states in each angular bin
    th_indices = np.digitize(th_i, th_bins) - 1
    th_indices = np.clip(th_indices, 0, n_theta_bins - 1)
    
    # Compute angular measure: dV_th[i] = (number of states in bin i) * dp^2
    # This approximates the angular density
    counts = np.bincount(th_indices, minlength=n_theta_bins)
    dV_th = counts * dV_p  # angular measure for each bin
    
    # Map each active state to its angular bin
    th_i_binned = th_centers[th_indices]
    
    return p_i, th_i_binned, dV_p, dV_th, th_centers, th_indices


def compute_angular_distribution(Ma, meta, p_i, th_indices, dV_p, dV_th, th_centers):
    """
    Compute angular distribution by applying collision operator to test functions.
    
    Original code computes: core[i] = eta^T I[:,:,i] eta for each angular mode i,
    then dist[i] = core[i] * sqrt(dV_th[0]) * sqrt(dV_th[i])
    
    For bruteforce matrix M (2D), we:
    1. Apply M to eta: M @ eta
    2. Compute eta * (M @ eta) for each state
    3. Bin by angle to get angular distribution
    """
    # Test function: eta = sqrt(p * dV_p) for number conservation
    # This matches the original: eta = np.sqrt(p_i * dV_p)
    eta = np.sqrt(p_i * dV_p)
    
    # Apply collision operator: M @ eta
    if isinstance(Ma, csr_matrix):
        M_eta = Ma.dot(eta)
    else:
        M_eta = Ma @ eta
    
    # Compute quadratic form: eta * (M @ eta) for each state
    # This is analogous to eta^T I[:,:,i] eta in the original
    core = eta * M_eta
    
    # Bin by angular index to get angular distribution
    # This gives us core[i] for each angular bin i
    n_theta_bins = len(th_centers)
    core_binned = np.zeros(n_theta_bins)
    for i, th_idx in enumerate(th_indices):
        core_binned[th_idx] += core[i]
    
    # Normalize similar to original code:
    # dist[i] = core[i] * sqrt(dV_th[0]) * sqrt(dV_th[i])
    dist = np.zeros(n_theta_bins)
    nonzero_mask = dV_th > 0
    if np.any(nonzero_mask):
        if dV_th[0] > 0:
            dist[nonzero_mask] = (core_binned[nonzero_mask] * 
                                  np.sqrt(dV_th[0]) * 
                                  np.sqrt(dV_th[nonzero_mask]))
        else:
            # Fallback if first bin is empty
            first_nonzero = np.where(nonzero_mask)[0][0] if np.any(nonzero_mask) else 0
            if dV_th[first_nonzero] > 0:
                dist[nonzero_mask] = (core_binned[nonzero_mask] * 
                                     np.sqrt(dV_th[first_nonzero]) * 
                                     np.sqrt(dV_th[nonzero_mask]))
    
    return dist, th_centers, dV_th


def load_bruteforce_matrices(matrix_dir=MATRIX_DIR):
    """
    Load all bruteforce matrices from the directory.
    Returns: dict mapping Theta -> (matrix, meta)
    """
    matrices = {}
    pattern = os.path.join(matrix_dir, "M_Iee_N*_dp*_T*.pkl")
    files = glob.glob(pattern)
    
    if not files:
        raise FileNotFoundError(f"No matrix files found in {matrix_dir}. Pattern: {pattern}")
    
    print(f"Found {len(files)} matrix files", flush=True)
    
    for fname in sorted(files):
        try:
            with open(fname, 'rb') as fp:
                M_sparse, meta = pickle.load(fp)
            
            Theta = float(meta["Theta"])
            
            # Convert sparse to dense if needed (for small matrices)
            # For large matrices, keep sparse
            if isinstance(M_sparse, csr_matrix):
                if M_sparse.shape[0] < 10000:
                    M_dense = M_sparse.toarray()
                else:
                    M_dense = M_sparse  # keep sparse for large matrices
            else:
                M_dense = M_sparse
            
            matrices[Theta] = (M_dense, meta)
            print(f"Loaded: Theta={Theta:.6g}, Nactive={len(meta['active'])}, "
                  f"Nmax={meta['Nmax']}, dp={meta['dp']:.6g}", flush=True)
        except Exception as e:
            print(f"Error loading {fname}: {e}", flush=True)
            continue
    
    return matrices


def main():
    print("=== Eigenvalue / angular-distribution postprocessing (bruteforce) ===", flush=True)
    
    # Load matrices
    matrices = load_bruteforce_matrices()
    Thetas = sorted(matrices.keys())
    print(f"Thetas={Thetas}", flush=True)
    print()
    
    # Compute eigenvalues
    eigs = {}
    
    for Theta in Thetas:
        print(f"[compute] Theta={Theta:.6g}", flush=True)
        Ma, meta = matrices[Theta]
        
        # Reconstruct momentum grid
        p_i, th_i, dV_p, dV_th, th_centers, th_indices = reconstruct_momentum_grid(meta)
        
        # Compute angular distribution
        dist, th_centers_used, dV_th_used = compute_angular_distribution(
            Ma, meta, p_i, th_indices, dV_p, dV_th, th_centers
        )
        
        eigs[Theta] = {}
        
        # Compute Fourier transform for each angular mode m
        # Match original normalization: dist_normed = dist[1:] / dV_th[1:] / dV_th[0]
        nonzero_mask = dV_th_used > 0
        if np.any(nonzero_mask):
            # Get valid bins (skip first one like original: [1:])
            valid_indices = np.where(nonzero_mask)[0]
            if len(valid_indices) > 1:
                # Skip first valid bin (similar to original's dist[1:])
                valid_indices = valid_indices[1:]
                th_valid = th_centers_used[valid_indices]
                dist_valid = dist[valid_indices]
                dV_th_valid = dV_th_used[valid_indices]
                
                # Normalize: dist_normed = dist[1:] / dV_th[1:] / dV_th[0]
                if dV_th_used[0] > 0:
                    dist_normed = dist_valid / dV_th_valid / dV_th_used[0]
                else:
                    # Fallback: use first valid bin as reference
                    first_valid_idx = np.where(nonzero_mask)[0][0]
                    dist_normed = dist_valid / dV_th_valid / dV_th_used[first_valid_idx]
                
                # Fourier transform: dist_normed * dV_th[1:], th_i[1:], dV_th
                for m in ms:
                    eigs[Theta][m] = Fourier_transform2(
                        dist_normed * dV_th_valid,
                        th_valid,
                        dV_th_used,  # Use full dV_th array like original
                        m
                    )
            else:
                # Not enough bins
                for m in ms:
                    eigs[Theta][m] = 0.0
        else:
            # Fallback: set to zero if no valid bins
            for m in ms:
                eigs[Theta][m] = 0.0
    
    # ---- Plot eigenvalues as in original script (Figure-1 style) ----
    f10, ax10 = plt.subplots(figsize=(8*0.9, 6*0.9))
    
    for m in ms:
        y = []
        y0 = []
        for Theta in Thetas:
            y.append(eigs[Theta][m])
            if k == 0:
                y0.append(eigs[Theta][0])
            else:
                y0.append(eigs[Theta][1])
        
        power = 2  # same choices as original
        
        # Only plot m != 0,1 prominently (same logic as original code)
        if k == 0 and m != 0 and m != 1:
            # Filter out invalid values
            y_arr = np.array(y)
            y0_arr = np.array(y0)
            Thetas_arr = np.array(Thetas)
            valid = (y_arr - y0_arr) > 0
            if np.any(valid):
                log_thetas = np.log(Thetas_arr[valid])
                log_vals = 3*np.log(2*np.pi) + np.log((y_arr[valid] - y0_arr[valid])/(Thetas_arr[valid]**power))
                # Only plot if we have enough points
                if len(log_vals) > 6:
                    ax10.plot(log_thetas[6:], log_vals[6:],
                              label=f"m = {m}", linewidth=1.5)
            
            print(f"m={m}", log_thetas[6:] if len(log_vals) > 6 else [], 
                  log_vals[6:] if len(log_vals) > 6 else [])
    
    # m=1 dashed special line (as in original)
    if k == 0:
        m = 1
        y = []
        y0 = []
        for Theta in Thetas:
            y.append(eigs[Theta][m])
            y0.append(eigs[Theta][0])
        power = 2
        y_arr = np.array(y)
        y0_arr = np.array(y0)
        Thetas_arr = np.array(Thetas)
        valid = (y_arr - y0_arr) > 0
        if np.any(valid):
            log_thetas = np.log(Thetas_arr[valid])
            log_vals = 3*np.log(2*np.pi) + np.log((y_arr[valid] - y0_arr[valid])/(Thetas_arr[valid]**power))
            if len(log_vals) > 5:
                ax10.plot(log_thetas[5:], log_vals[5:],
                          label="m = 1", linestyle="--", linewidth=1.5, color="gray")
                print("m=1", log_thetas[5:], log_vals[5:])
    
    # Reference lines (same as original)
    x_ref = np.linspace(-4.7, -3.0, 100)
    y_center = (2.2 + (-3.0)) / 2
    x_center = -3.0
    
    x_ref = np.linspace(-4.7, -3.0, 100)
    y_ref_2 = 1.9 + 0.0 * (x_ref - x_center)
    ax10.plot(x_ref, y_ref_2, 'r--', alpha=0.6, linewidth=1.5, label=r'$T^2$')
    
    x_ref = np.linspace(-4.7, -3.0, 100)
    y_ref_33 = 0.68 + 1.3 * (x_ref - x_center)
    ax10.plot(x_ref, y_ref_33, 'b-.', alpha=0.6, linewidth=1.5, label=r'$T^{3.3}$')
    
    x_ref = np.linspace(-4.5, -3, 100)
    y_ref_39 = y_center + 1.9 * (x_ref - x_center)
    ax10.plot(x_ref, y_ref_39, 'm:', alpha=0.6, linewidth=1.5, label=r'$T^{3.9}$')
    
    x_ref = np.linspace(-4.7, -2.0, 100)
    y_ref_4 = -3 + 2.0 * (x_ref - x_center)
    ax10.plot(x_ref, y_ref_4, 'g:', alpha=0.6, linewidth=2, label=r'$T^4$')
    
    ax10.set_xlim(-4.7, 0.5)
    ax10.set_ylim(-3.0, 2.2)
    ax10.set_xlabel(r'Temperature, $\ln (T/T_F)$')
    ax10.set_ylabel(r'Eigenvalues, $\ln(\lambda_m T_F^2/T^2)$')
    ax10.legend()
    
    f10.tight_layout()
    f10.savefig('./Eigenvals_bruteforce.svg')
    f10.savefig('./Eigenvals_bruteforce.png', dpi=300)
    print("Saved: ./Eigenvals_bruteforce.svg", flush=True)
    
    plt.show()


if __name__ == "__main__":
    main()

