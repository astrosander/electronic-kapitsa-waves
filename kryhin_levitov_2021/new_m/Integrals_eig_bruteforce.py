# Integrals_eig_bruteforce.py
# Eigenvalue computation for matrices generated by Iee_matrix_bruteforce_generate.py

import os
import glob
import numpy as np
import pickle
import math
import csv
from scipy.sparse import csr_matrix, diags
from scipy.sparse.linalg import eigsh, eigs, lobpcg
from matplotlib import pyplot as plt
from numpy.polynomial.hermite import hermval

# ----------------------------
# Configuration
# ----------------------------
ms = [0, 1, 2, 3, 4]  # extend if needed
k = 0  # Figure-1 style (no "-a2" files)

RADIAL_BASIS_K = 6
RADIAL_SIGMA_P_MULT = 3.0
REG_ABS = 0.0

plt.rcParams["text.usetex"] = False
plt.rcParams["font.family"] = "serif"
plt.rcParams["legend.frameon"] = False

MATRIX_DIR = r"D:\Рабочая папка\GitHub\electronic-kapitsa-waves\kryhin_levitov_2021\collision_integral_direct\Matrixes_bruteforce"


# ----------------------------
# Utilities
# ----------------------------
def build_centered_lattice(Nmax: int):
    half = Nmax // 2
    ns = np.arange(-half, half, dtype=np.int32)
    nx, ny = np.meshgrid(ns, ns, indexing="ij")
    return nx.reshape(-1), ny.reshape(-1), half


def reconstruct_px_py(meta):
    Nmax = int(meta["Nmax"])
    dp = float(meta["dp"])
    shift_x = float(meta.get("shift_x", 0.0))
    shift_y = float(meta.get("shift_y", 0.0))
    active = meta["active"].astype(np.int32)

    nx_full, ny_full, _ = build_centered_lattice(Nmax)
    nx = nx_full[active].astype(np.float64)
    ny = ny_full[active].astype(np.float64)

    px = dp * (nx + shift_x)
    py = dp * (ny + shift_y)
    return px, py


def eps_from_meta(P, meta):
    U_bar = float(meta.get("U_bar", 0.0))
    V_bar = float(meta.get("V_bar", 1.0))
    return np.sqrt((V_bar * P) ** 2 + U_bar**2) - U_bar


def vg_from_meta(P, meta):
    U_bar = float(meta.get("U_bar", 0.0))
    V_bar = float(meta.get("V_bar", 1.0))
    denom = np.sqrt((V_bar * P) ** 2 + U_bar**2)
    return (V_bar**2 * P) / np.maximum(denom, 1e-30)


def wdot(u, v, w):
    return float(np.dot(u, w * v))


def wmean(x, w):
    return float(np.dot(w, x)) / (float(np.dot(w, np.ones_like(w))) + 1e-300)


def w_orthonormalize(vecs, w, remove_basis=None, drop_rel=1e-10):
    """
    W-orthonormalize list of vectors.
    drop_rel prevents reinjecting invariants when a vector is almost entirely projected out.
    """
    basis = []
    for v in vecs:
        u = v.astype(np.float64).copy()
        vnorm = math.sqrt(max(wdot(u, u, w), 0.0))
        if vnorm < 1e-300:
            continue

        if remove_basis is not None:
            for q in remove_basis:
                u -= wdot(q, u, w) * q

        for q in basis:
            u -= wdot(q, u, w) * q

        nrm = math.sqrt(max(wdot(u, u, w), 0.0))
        if nrm > 1e-30 and nrm > drop_rel * (vnorm + 1e-300):
            basis.append(u / nrm)
    return basis


def build_hg_basis(z, m, theta, K, wtype="both"):
    g = np.exp(-0.5 * z * z)
    basis = []
    for k in range(K):
        coeff = np.zeros(k + 1)
        coeff[-1] = 1.0
        Hk = hermval(z, coeff)
        rk = Hk * g
        if wtype in ("cos", "both"):
            basis.append(rk * np.cos(m * theta))
        if wtype in ("sin", "both"):
            basis.append(rk * np.sin(m * theta))
    return basis


def angular_power_ls(u, theta, w_safe, m_max=10):
    """
    Robust harmonic power for irregular theta sampling:
    Fit u(theta) ≈ a0 + Σ_{m>=1} [a_m cos(mθ) + b_m sin(mθ)]
    using weighted least squares with weights w_safe.
    Returns normalized power Pm with Pm[m] = a_m^2 + b_m^2 (Pm[0]=a0^2).
    """
    w = np.maximum(w_safe.astype(np.float64), 1e-30)
    sw = np.sqrt(w)

    n = theta.size
    # Design matrix: [1, cos θ, sin θ, cos 2θ, sin 2θ, ...]
    cols = [np.ones(n, dtype=np.float64)]
    for m in range(1, m_max + 1):
        cols.append(np.cos(m * theta))
        cols.append(np.sin(m * theta))
    X = np.column_stack(cols)

    Xw = sw[:, None] * X
    yw = sw * u

    # Weighted least squares
    coef, *_ = np.linalg.lstsq(Xw, yw, rcond=None)

    Pm = np.zeros(m_max + 1, dtype=np.float64)
    Pm[0] = coef[0] * coef[0]
    idx = 1
    for m in range(1, m_max + 1):
        a = coef[idx]
        b = coef[idx + 1]
        Pm[m] = a * a + b * b
        idx += 2

    Pm /= (Pm.sum() + 1e-300)
    return Pm



def residual_B_from_u(A, w_safe, u, gamma):
    """
    Residual in B y = gamma y where y = sqrt(W) u and B = W^{-1/2} A W^{-1/2}.
    This is the residual LOBPCG actually optimizes.
    """
    w_sqrt = np.sqrt(np.maximum(w_safe, 1e-300))
    w_inv_sqrt = 1.0 / w_sqrt

    y = w_sqrt * u
    Au = A.dot(u)
    By = w_inv_sqrt * Au

    num = np.linalg.norm(By - gamma * y)
    den = np.linalg.norm(By) + abs(gamma) * np.linalg.norm(y) + 1e-30
    return num / den


def apply_B_to_Y(A, w_safe, Y):
    """Compute BY = B Y with B = W^{-1/2} A W^{-1/2}, y-space."""
    w_safe = np.maximum(w_safe.astype(np.float64), 1e-30)
    w_inv_sqrt = 1.0 / np.sqrt(w_safe)
    U = w_inv_sqrt[:, None] * Y  # U = W^{-1/2} Y (v-space)
    AU = A.dot(U)                # A U
    BY = w_inv_sqrt[:, None] * AU  # W^{-1/2} A U = B Y
    return BY


def ritz_smallest_in_subspace_y(A, w_safe, Y):
    """
    Solve B y = gamma y in the subspace span(Y) where columns of Y are orthonormal.
    Returns (gammas, Yvecs) where eigenvectors are y = Y @ c.
    """
    BY = apply_B_to_Y(A, w_safe, Y)
    C = Y.T @ BY
    C = 0.5 * (C + C.T)  # should already be symmetric
    evals, evecs = np.linalg.eigh(C)
    evals = np.real(evals)
    evecs = np.real(evecs)
    idx = np.argsort(evals)
    return evals[idx], evecs[:, idx]


def build_constraints_y(w_safe, vecs_vspace):
    w_sqrt = np.sqrt(np.maximum(w_safe, 1e-300))
    Qy = w_sqrt[:, None] * np.column_stack(vecs_vspace)
    Qy, _ = np.linalg.qr(Qy)
    return Qy


def check_W_symmetry(A, w_safe, ntest=4, seed=0):
    rng = np.random.default_rng(seed)
    w_sqrt = np.sqrt(np.maximum(w_safe, 1e-300))
    w_inv_sqrt = 1.0 / w_sqrt

    def B_dot(y):
        u = w_inv_sqrt * y
        Au = A.dot(u)
        return w_inv_sqrt * Au

    rels = []
    for _ in range(ntest):
        x = rng.standard_normal(A.shape[0])
        y = rng.standard_normal(A.shape[0])
        Bx = B_dot(x)
        By = B_dot(y)
        lhs = float(np.dot(x, By))
        rhs = float(np.dot(Bx, y))
        denom = max(abs(lhs), abs(rhs), 1e-30)
        rels.append(abs(lhs - rhs) / denom)
    return max(rels), float(np.mean(rels))


# ----------------------------
# File I/O
# ----------------------------
def get_matrix_files(matrix_dir=MATRIX_DIR):
    pattern = os.path.join(matrix_dir, "M_Iee_N*_dp*_T*.pkl")
    files = glob.glob(pattern)
    if not files:
        raise FileNotFoundError(f"No matrix files found in {matrix_dir}. Pattern: {pattern}")

    files_with_theta = []
    for fname in files:
        try:
            with open(fname, "rb") as fp:
                M_sparse, meta = pickle.load(fp)
            Theta = float(meta["Theta"])
            files_with_theta.append((Theta, fname))
        except Exception as e:
            print(f"Error reading {fname}: {e}", flush=True)
            continue

    files_with_theta.sort(key=lambda x: x[0])
    return files_with_theta


def load_single_matrix(fname):
    with open(fname, "rb") as fp:
        M_sparse, meta = pickle.load(fp)
    return M_sparse, meta


# ----------------------------
# Eigenfunctions by mode
# ----------------------------
def compute_eigenfunctions_by_mode(Ma, meta, ms):
    w_active = meta["w_active"].astype(np.float64)
    w_safe = np.clip(w_active, 1e-30, None)

    px, py = reconstruct_px_py(meta)
    theta = np.arctan2(py, px)
    P = np.sqrt(px * px + py * py)
    Theta = float(meta.get("Theta", 0.0))
    dp = float(meta.get("dp", 0.0))

    # consistent eps/vg
    eps_raw = eps_from_meta(P, meta)
    vg = vg_from_meta(P, meta)
    vx = vg * np.cos(theta)
    vy = vg * np.sin(theta)

    ebar = float(np.dot(w_safe, eps_raw)) / (float(np.dot(w_safe, np.ones_like(eps_raw))) + 1e-30)
    eps_c = (eps_raw - ebar).astype(np.float64)

    # Build collision operator A = -M (sparse)
    if isinstance(Ma, csr_matrix):
        A = -Ma
    elif isinstance(Ma, np.ndarray):
        A = csr_matrix(-Ma)
    else:
        A = csr_matrix(-Ma)

    # IMPORTANT: symmetrize in plain transpose (works because you verified W-selfadjointness)
    A = 0.5 * (A + A.T)

    if REG_ABS > 0.0:
        n = A.shape[0]
        A = A + diags([REG_ABS] * n, 0, format="csr")

    # sanity checks
    sym_max, sym_mean = check_W_symmetry(A, w_safe, ntest=6, seed=1)
    print(f"  [sanity] W-selfadjoint test: max={sym_max:.2e} mean={sym_mean:.2e}", flush=True)

    Apx_rel = np.linalg.norm(A.dot(px)) / (np.linalg.norm(px) + 1e-30)
    Apy_rel = np.linalg.norm(A.dot(py)) / (np.linalg.norm(py) + 1e-30)
    ones = np.ones_like(px)
    A1_rel = np.linalg.norm(A.dot(ones)) / (np.linalg.norm(ones) + 1e-30)
    Aeps_rel = np.linalg.norm(A.dot(eps_c)) / (np.linalg.norm(eps_c) + 1e-30)

    print(f"  [sanity] ||A px||/||px|| = {Apx_rel:.6e}", flush=True)
    print(f"  [sanity] ||A py||/||py|| = {Apy_rel:.6e}", flush=True)
    print(f"  [sanity] ||A 1||/||1||   = {A1_rel:.6e}", flush=True)
    print(f"  [sanity] ||A eps_c||/||eps_c|| = {Aeps_rel:.6e}", flush=True)

    # Treat energy invariant ONLY if it's truly conserved (your logs show it's leaky at low T)
    ENERGY_LEAK_THR = 1e-10
    use_energy = (Aeps_rel < ENERGY_LEAK_THR)
    if use_energy:
        print("  [sanity] energy treated as invariant", flush=True)
    else:
        print("  [sanity] energy NOT treated as invariant (too leaky)", flush=True)

    inv_vecs = [ones.astype(np.float64), px.astype(np.float64), py.astype(np.float64)]
    if use_energy:
        inv_vecs.insert(1, eps_c.astype(np.float64))

    inv_orth = w_orthonormalize(inv_vecs, w_safe, remove_basis=None)

    def wcorr(u, v):
        nu = math.sqrt(max(wdot(u, u, w_safe), 0.0))
        nv = math.sqrt(max(wdot(v, v, w_safe), 0.0))
        if nu * nv < 1e-300:
            return 0.0
        return wdot(u, v, w_safe) / (nu * nv)

    eigenfunctions = {}
    eigenvalues = {}

    # Prebuild B operator pieces for LOBPCG use
    w_inv_sqrt = 1.0 / np.sqrt(w_safe)
    D = diags(w_inv_sqrt, 0, format="csr")
    B = D @ A @ D
    B = 0.5 * (B + B.T)

    for m in ms:
        if m == 0:
            # Always the density invariant: gamma = 0
            if len(inv_orth) > 0:
                u = inv_orth[0].copy()
            else:
                u = ones.astype(np.float64).copy()
                u /= math.sqrt(max(wdot(u, u, w_safe), 1e-30))
            eigenfunctions[m] = u
            eigenvalues[m] = 0.0
            print("  [m=0] gamma=0 (density invariant)", flush=True)
            continue

        if m == 1:
            # --- Robust m=1: strict invariant removal + Rayleigh quotient gamma ---
            # Key: avoid reinjecting invariants by normalizing nearly-zero vectors.

            n = A.shape[0]
            w_safe = np.maximum(w_safe.astype(np.float64), 1e-30)

            def project_out_span(v, span):
                out = v.astype(np.float64).copy()
                for q in span:
                    out -= wdot(q, out, w_safe) * q
                return out

            def normalize_W(v):
                nrm = math.sqrt(max(wdot(v, v, w_safe), 0.0))
                if nrm < 1e-300:
                    return None
                return v / nrm

            def rayleigh_gamma(u):
                Au = A.dot(u)
                den = wdot(u, u, w_safe) + 1e-300
                return float(np.dot(u, Au) / den)

            # Build "projected current" targets (orthogonal to invariants)
            jx_perp = normalize_W(project_out_span(vx, inv_orth))
            jy_perp = normalize_W(project_out_span(vy, inv_orth))

            # If the true j⊥ is extremely tiny, we still proceed but corr(j_perp) will be small.
            have_j = (jx_perp is not None) or (jy_perp is not None)

            # Shell width from the active set itself
            sigma_shell = math.sqrt(max(wmean((P - 1.0) ** 2, w_safe), 1e-30))
            sigma_list = [
                max(2.0 * sigma_shell, 6.0 * dp, 1e-12),
                max(4.0 * sigma_shell, 6.0 * dp, 1e-12),
                max(8.0 * sigma_shell, 8.0 * dp, 1e-12),
            ]
            K_LIST = [12, 18, 24, 32, 40, 56]

            # Momentum contamination tolerances to try (tight -> loose)
            MOM_TOLS = [5e-3, 2e-2, 1e-1]

            best = None
            # best tuple: (resB, gamma, u, resA, corrj, cpx, cpy, K_use, sigma_p)

            for mom_tol in MOM_TOLS:
                best = None

                for sigma_p in sigma_list:
                    z = (P - 1.0) / sigma_p
                    g = np.exp(-0.5 * z * z)

                    for K_use in K_LIST:
                        basis = []

                        # Good seeds (all will be projected orthogonal to invariants)
                        basis += [vx, vy, (P - 1.0) * vx, (P - 1.0) * vy]

                        # Hermite-Gauss m=1 blocks; start at k=1 to avoid the most momentum-like shape
                        for k_h in range(1, K_use + 1):
                            coeff = np.zeros(k_h + 1); coeff[-1] = 1.0
                            Hk = hermval(z, coeff)
                            rk = Hk * g
                            bc = rk * np.cos(theta)
                            bs = rk * np.sin(theta)
                            basis += [bc, bs, vg * bc, vg * bs]

                        # Build W-orthonormal subspace U, but DROP vectors that collapse after projection
                        U_list = []
                        for b in basis:
                            b0 = b.astype(np.float64)
                            bproj = project_out_span(b0, inv_orth)

                            # Drop if almost entirely killed (prevents noise normalization)
                            nb0 = math.sqrt(max(wdot(b0, b0, w_safe), 0.0))
                            nbp = math.sqrt(max(wdot(bproj, bproj, w_safe), 0.0))
                            if nb0 < 1e-300 or nbp < 1e-12 * nb0:
                                continue

                            bproj = bproj / (nbp + 1e-300)
                            U_list.append(bproj)

                        # W-orthonormalize (no extra remove_basis needed since we already projected)
                        U_list = w_orthonormalize(U_list, w_safe, remove_basis=None, drop_rel=1e-8)
                        if len(U_list) < 10:
                            continue

                        U = np.column_stack(U_list)  # columns W-orthonormal

                        # Ritz in this W-orthonormal subspace: (U^T A U) c = gamma c
                        AU = A.dot(U)
                        C = U.T @ AU
                        C = 0.5 * (C + C.T)

                        evals, evecs = np.linalg.eigh(C)
                        evals = np.real(evals)
                        evecs = np.real(evecs)

                        scale = max(1.0, float(np.max(np.abs(evals))))
                        tol_pos = 1e-12 * scale

                        # Scan smallest positive eigenvalues
                        for j in np.argsort(evals)[: min(60, len(evals))]:
                            gamma0 = float(evals[j])
                            if not np.isfinite(gamma0) or gamma0 <= tol_pos:
                                continue

                            u_try = (U @ evecs[:, j]).astype(np.float64)

                            # RE-PROJECT AGAIN (crucial) and renormalize
                            u_try = project_out_span(u_try, inv_orth)
                            u_try = normalize_W(u_try)
                            if u_try is None:
                                continue

                            # Enforce small momentum leakage
                            cpx = wcorr(u_try, px)
                            cpy = wcorr(u_try, py)
                            if abs(cpx) > mom_tol or abs(cpy) > mom_tol:
                                continue

                            # Recompute gamma via Rayleigh quotient after projection (stabilizes residual)
                            gamma = rayleigh_gamma(u_try)
                            if gamma <= 0.0:
                                continue

                            # Residuals
                            Au = A.dot(u_try)
                            Wu = w_safe * u_try
                            resA = np.linalg.norm(Au - gamma * Wu) / (
                                np.linalg.norm(Au) + abs(gamma) * np.linalg.norm(Wu) + 1e-30
                            )
                            resB = residual_B_from_u(A, w_safe, u_try, gamma)

                            # Current-overlap in the projected sense
                            corrj = 0.0
                            if jx_perp is not None:
                                corrj = max(corrj, abs(wcorr(u_try, jx_perp)))
                            if jy_perp is not None:
                                corrj = max(corrj, abs(wcorr(u_try, jy_perp)))

                            cand = (resB, gamma, u_try, resA, corrj, cpx, cpy, K_use, sigma_p)
                            if (best is None) or (cand[0] < best[0]):  # minimize resB first
                                best = cand

                            # Early exit if we have a decent eigenpair
                            if resB < 5e-2:
                                break

                        if best is not None and best[0] < 5e-2:
                            break
                    if best is not None and best[0] < 5e-2:
                        break
                if best is not None:
                    break  # accept first mom_tol that yields something

            if best is None:
                print("  [m=1] failed to find relaxing m=1 mode (orthogonal to momentum)", flush=True)
                eigenfunctions[m] = None
                eigenvalues[m] = np.nan
                continue

            resB, gamma, u, resA, corrj, cpx, cpy, K_use, sigma_p = best
            print(
                f"  [m=1] gamma={gamma:.6e}, corr(j_perp)={corrj:.3e}, "
                f"corr(px)={cpx:+.2e}, corr(py)={cpy:+.2e}, "
                f"residual_A={resA:.3e}, residual_B={resB:.3e}, K={K_use}, sigma_p={sigma_p:.3e}",
                flush=True,
            )

        else:
            # m >= 2: Ritz in a tailored HG basis with invariant removal
            remove = inv_orth[:] if len(inv_orth) else None

            TARGET_RES = 5e-2
            K_LIST_EVEN = [6, 10, 14]
            K_LIST_ODD = [10, 14, 18, 24, 32, 40]

            best = None  # (resA, gamma, u, K_use, sigma_p)

            for K_use in (K_LIST_ODD if (m % 2 == 1) else K_LIST_EVEN):
                if m % 2 == 1:
                    sigma_p = max(20.0 * (0.5 * Theta), 6.0 * dp, 1e-12)
                else:
                    sigma_p = max(3.0 * (0.5 * Theta), 4.0 * dp, 1e-12)

                z = (P - 1.0) / sigma_p
                basis = build_hg_basis(z, m, theta, K_use, wtype="both")
                U_list = w_orthonormalize(basis, w_safe, remove_basis=remove, drop_rel=1e-10)
                if len(U_list) == 0:
                    continue

                Umat = np.column_stack(U_list)
                AU = A.dot(Umat)
                C = Umat.T @ AU
                C = 0.5 * (C + C.T)

                evals, evecs = np.linalg.eigh(C)
                evals = np.real(evals)

                # pick smallest positive eigenvalue above numerical tolerance
                scale = max(1.0, float(np.max(np.abs(evals))))
                tol = 1e-12 * scale
                pos = np.where(evals > tol)[0]
                if len(pos) == 0:
                    # fallback: smallest |eval|
                    jloc = int(np.argmin(np.abs(evals)))
                else:
                    jloc = int(pos[np.argmin(evals[pos])])
                gamma_try = float(evals[jloc])

                u_try = (Umat @ evecs[:, jloc]).astype(np.float64)
                u_try /= math.sqrt(max(wdot(u_try, u_try, w_safe), 1e-30))

                # residual in A-form
                Au = A.dot(u_try)
                Wu = w_safe * u_try
                resA = np.linalg.norm(Au - gamma_try * Wu) / (
                    np.linalg.norm(Au) + abs(gamma_try) * np.linalg.norm(Wu) + 1e-30
                )

                best = (resA, gamma_try, u_try, K_use, sigma_p)
                if resA <= TARGET_RES:
                    break

            if best is None:
                print(f"  [m={m}] no valid basis", flush=True)
                eigenfunctions[m] = None
                eigenvalues[m] = float("nan")
                continue

            resA, gamma, u, K_use, sigma_p = best
            resB = residual_B_from_u(A, w_safe, u, gamma)
            print(
                f"  [m={m}] gamma={gamma:.6e}, residual_A={resA:.3e}, residual_B={resB:.3e}, "
                f"K={K_use}, sigma_p={sigma_p:.3e}",
                flush=True,
            )

        # store
        eigenfunctions[m] = u
        eigenvalues[m] = gamma

        # diagnostics
        if m == 1:
            print(
                f"  [m={m}] corr: dens={wcorr(u, ones):+.2e}  en={wcorr(u, eps_c):+.2e}  "
                f"px={wcorr(u, px):+.2e} py={wcorr(u, py):+.2e}  "
                f"jx={wcorr(u, vx):+.2e} jy={wcorr(u, vy):+.2e}",
                flush=True,
            )
        else:
            print(
                f"  [m={m}] corr: dens={wcorr(u, ones):+.2e}  en={wcorr(u, eps_c):+.2e}  "
                f"px={wcorr(u, px):+.2e} py={wcorr(u, py):+.2e}  "
                f"vx={wcorr(u, vx):+.2e} vy={wcorr(u, vy):+.2e}",
                flush=True,
            )

        Au = A.dot(u)
        Wu = w_safe * u
        resA = np.linalg.norm(Au - gamma * Wu) / (np.linalg.norm(Au) + abs(gamma) * np.linalg.norm(Wu) + 1e-30)
        resB = residual_B_from_u(A, w_safe, u, gamma)
        print(f"  [m={m}] residual_A={resA:.3e}  residual_B={resB:.3e}", flush=True)

    return eigenfunctions, eigenvalues, px, py


# ----------------------------
# Main workflow
# ----------------------------
def main():
    print("=== Eigenvalue postprocessing (bruteforce) ===", flush=True)

    files_with_theta = get_matrix_files()
    Thetas = [theta for theta, _ in files_with_theta]

    print(f"Found {len(files_with_theta)} matrix files", flush=True)
    print(f"Thetas={Thetas}", flush=True)
    print()

    all_eigenvalues = {}

    for Theta, fname in files_with_theta:
        print(f"\n[compute eigenfunctions] Theta={Theta:.6g}", flush=True)
        print(f"  Loading matrix from {os.path.basename(fname)}...", flush=True)

        Ma, meta = load_single_matrix(fname)
        print(f"  Matrix shape: {Ma.shape}, type: {type(Ma).__name__}", flush=True)

        eigenfunctions, eigenvalues, px, py = compute_eigenfunctions_by_mode(Ma, meta, ms=ms)
        all_eigenvalues[Theta] = eigenvalues

        del Ma, meta
        import gc
        gc.collect()

    # Save to CSV
    csv_filename = "./Eigenvals_bruteforce.csv"
    with open(csv_filename, "w", newline="") as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(["T"] + [f"m{m}" for m in ms])
        for Theta in Thetas:
            writer.writerow([Theta] + [all_eigenvalues[Theta].get(m, 0.0) for m in ms])

    print(f"\nSaved: {csv_filename}", flush=True)

    # Plot (Figure-1 style)
    f10, ax10 = plt.subplots(figsize=(8 * 0.9, 6 * 0.9))

    # IMPORTANT BUGFIX: m0 is zero by construction, so y-y0 must use m0 baseline carefully.
    # For k=0: baseline is m=0 which is 0. That’s fine.
    for m in ms:
        y = np.array([all_eigenvalues[T].get(m, 0.0) for T in Thetas], dtype=np.float64)
        y0 = np.array([all_eigenvalues[T].get(0, 0.0) for T in Thetas], dtype=np.float64)

        if k == 0 and m not in (0, 1):
            power = 2
            diff = y - y0
            valid = (diff > 0) & (np.array(Thetas) > 0)
            if np.any(valid):
                log_t = np.log(np.array(Thetas)[valid])
                log_val = 3 * np.log(2 * np.pi) + np.log(diff[valid] / (np.array(Thetas)[valid] ** power))
                # do not discard first 6 points blindly (was a bug for short theta lists)
                ax10.plot(log_t, log_val, label=f"m = {m}", linewidth=1.5)

    # m=1 dashed line
    if k == 0 and 1 in ms:
        y = np.array([all_eigenvalues[T].get(1, 0.0) for T in Thetas], dtype=np.float64)
        y0 = np.array([all_eigenvalues[T].get(0, 0.0) for T in Thetas], dtype=np.float64)
        power = 2
        diff = y - y0
        valid = (diff > 0) & (np.array(Thetas) > 0)
        if np.any(valid):
            log_t = np.log(np.array(Thetas)[valid])
            log_val = 3 * np.log(2 * np.pi) + np.log(diff[valid] / (np.array(Thetas)[valid] ** power))
            ax10.plot(log_t, log_val, label="m = 1", linestyle="--", linewidth=1.5, color="gray")

    ax10.set_xlabel(r"Temperature, $\ln (T/T_F)$")
    ax10.set_ylabel(r"Eigenvalues, $\ln(\lambda_m T_F^2/T^2)$")
    ax10.legend()
    f10.tight_layout()

    out_png = "./Eigenvals_bruteforce.png"
    f10.savefig(out_png, dpi=300, bbox_inches="tight")
    print(f"Saved: {out_png}", flush=True)

    plt.show()


if __name__ == "__main__":
    main()
