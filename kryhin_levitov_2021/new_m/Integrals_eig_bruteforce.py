# Integrals_eig_bruteforce.py
# Eigenvalue computation for matrices generated by Iee_matrix_bruteforce_generate.py
import os
import glob
import numpy as np
import pickle
import math
from scipy.sparse import csr_matrix, diags
from scipy.sparse.linalg import eigsh, eigs, lobpcg
from matplotlib import pyplot as plt
from matplotlib.colors import TwoSlopeNorm
from numpy.polynomial.hermite import hermval

# Configuration
ms = [0, 1, 2, 3, 4]#, 5, 6]#, 7, 8,9,10,11,12,13,14,15,16,18,19,20]#[0, 1, 2, 3, 4, 5, 6, 7, 8]
k = 0  # Figure-1 style (no "-a2" files)

# PATCH: allow radial structure in each angular mode (critical for T^4 odd-m asymptotics)
RADIAL_BASIS_K = 6          # number of radial powers (k=0..K-1); 6–10 usually enough
RADIAL_SIGMA_P_MULT = 3.0   # sets Gaussian envelope width in p around p=1

# PATCH: do NOT add an absolute diagonal regularization when chasing tiny low-T rates.
# If you need stabilization, use a RELATIVE regularization tied to matrix scale.
REG_ABS = 0.0

plt.rcParams['text.usetex'] = False
plt.rcParams['font.family'] = 'serif'
plt.rcParams["legend.frameon"] = False

# Directory where bruteforce matrices are stored
MATRIX_DIR = r"D:\Рабочая папка\GitHub\electronic-kapitsa-waves\kryhin_levitov_2021\collision_integral_direct\Matrixes_bruteforce"#"collision_integral_direct/Matrixes_bruteforce"


def _theta_str(theta: float) -> str:
    """Format theta for filename matching."""
    return f"{theta:.10g}"


def Fourier_transform2(func, th_i, dV_th, m):
    """Fourier transform for angular mode m."""
    exp = np.cos(th_i * m)
    integ = func * exp
    return np.sum(integ)


def build_centered_lattice(Nmax: int):
    """Build centered momentum lattice indices (same as in generator)."""
    half = Nmax // 2
    ns = np.arange(-half, half, dtype=np.int32)
    nx, ny = np.meshgrid(ns, ns, indexing="ij")
    nx = nx.reshape(-1)
    ny = ny.reshape(-1)
    return nx, ny, half


def reconstruct_px_py(meta):
    """
    Reconstruct px, py for active states from metadata.
    Returns: px, py arrays for active states
    """
    Nmax = int(meta["Nmax"])
    dp = float(meta["dp"])
    half = int(meta["half"])
    shift_x = float(meta.get("shift_x", 0.0))
    shift_y = float(meta.get("shift_y", 0.0))
    active = meta["active"].astype(np.int32)
    
    # Reconstruct full lattice
    nx_full, ny_full, _ = build_centered_lattice(Nmax)
    
    # Get active states
    nx_active = nx_full[active]
    ny_active = ny_full[active]
    
    # Compute physical momenta
    px = dp * (nx_active.astype(np.float64) + shift_x)
    py = dp * (ny_active.astype(np.float64) + shift_y)
    
    return px, py


def reconstruct_momentum_grid(meta):
    """
    Reconstruct momentum grid for active states from metadata.
    Returns: p_i (magnitude), th_i (angle), dV_p (radial measure), dV_th (angular measure)
    
    Create angular bins similar to original: use uniform angular grid with ~100 points.
    """
    Nmax = int(meta["Nmax"])
    dp = float(meta["dp"])
    half = int(meta["half"])
    shift_x = float(meta.get("shift_x", 0.0))
    shift_y = float(meta.get("shift_y", 0.0))
    active = meta["active"].astype(np.int32)
    
    # Reconstruct full lattice
    nx_full, ny_full, _ = build_centered_lattice(Nmax)
    
    # Get active states
    nx_active = nx_full[active]
    ny_active = ny_full[active]
    
    # Compute physical momenta
    px = dp * (nx_active.astype(np.float64) + shift_x)
    py = dp * (ny_active.astype(np.float64) + shift_y)
    p_i = np.sqrt(px * px + py * py)
    th_i = np.arctan2(py, px)  # angle in [-pi, pi]
    
    # Radial measure: dp^2 for 2D (area element in momentum space)
    dV_p = dp * dp
    
    # Create angular bins: use uniform grid like original (N_th = 100)
    # But adjust to match the actual distribution of angles
    # PATCH: higher angular resolution improves reconstruction accuracy
    # (does not change matrices, only postprocessing). With finer dp and half-integer shift,
    # you can safely use more bins without throwing away resolution.
    n_theta_bins = 360  # Level-2: increased from 100; Level-3: use 720 for very smooth Fourier modes
    th_bins = np.linspace(-np.pi, np.pi, n_theta_bins + 1)
    th_centers = 0.5 * (th_bins[:-1] + th_bins[1:])
    
    # Assign each state to an angular bin
    th_indices = np.digitize(th_i, th_bins) - 1
    th_indices = np.clip(th_indices, 0, n_theta_bins - 1)
    
    # Compute angular measure: dV_th[i] = (number of states in bin i) * dp^2
    counts = np.bincount(th_indices, minlength=n_theta_bins)
    dV_th = counts * dV_p
    
    return p_i, th_i, dV_p, dV_th, th_centers, th_indices


def eps_from_meta(P, meta):
    """
    Single-particle energy for a Dirac-like spectrum with gap U_bar and velocity V_bar:
        eps(p) = sqrt((V_bar * p)^2 + U_bar^2) - U_bar
    """
    U_bar = float(meta.get("U_bar", 0.0))
    V_bar = float(meta.get("V_bar", 1.0))
    return np.sqrt((V_bar * P) ** 2 + U_bar ** 2) - U_bar


def vg_from_meta(P, meta):
    """
    Group velocity magnitude v_g(p) = d eps / d p for the same dispersion.
    """
    U_bar = float(meta.get("U_bar", 0.0))
    V_bar = float(meta.get("V_bar", 1.0))
    denom = np.sqrt((V_bar * P) ** 2 + U_bar ** 2)
    return (V_bar ** 2 * P) / np.maximum(denom, 1e-30)


def compute_angular_distribution(Ma, meta, p_i, th_i, th_indices, dV_p, dV_th, th_centers):
    """
    Compute angular distribution by applying collision operator to test functions.
    
    Original code: core[i] = eta^T I[:,:,i] eta for each angular mode i
    where I[:,:,i] is the collision operator matrix for angular mode i.
    
    For bruteforce matrix M (2D), we need to compute the equivalent:
    - The matrix I[:,:,i] represents the collision operator projected onto angular mode i
    - We compute: core[i] = sum over states j in angular bin i of (eta[j] * (M @ eta)[j])
    - This approximates eta^T I[:,:,i] eta by binning the result
    """
    # Test function: eta = sqrt(p * dV_p) for number conservation
    # This matches the original: eta = np.sqrt(p_i * dV_p)
    eta = np.sqrt(p_i * dV_p)
    
    # Apply collision operator: M @ eta
    # This gives the collision operator's action at each momentum state
    if isinstance(Ma, csr_matrix):
        M_eta = Ma.dot(eta)
    else:
        M_eta = Ma @ eta
    
    # Compute quadratic form per state: eta[j] * (M @ eta)[j]
    # This is the contribution from state j
    core_per_state = eta * M_eta
    
    # Bin by angular index to get core[i] for each angular bin i
    # This approximates eta^T I[:,:,i] eta by summing contributions from states in bin i
    n_theta_bins = len(th_centers)
    core = np.zeros(n_theta_bins)
    for j, th_idx in enumerate(th_indices):
        core[th_idx] += core_per_state[j]
    
    # Normalize: dist[i] = core[i] * sqrt(dV_th[0]) * sqrt(dV_th[i])
    # This matches the original: dist = core * np.sqrt(dV_th[0]) * np.sqrt(dV_th)
    dist = np.zeros(n_theta_bins)
    nonzero_mask = dV_th > 0
    if np.any(nonzero_mask):
        # Use first bin as reference (original uses dV_th[0])
        # If first bin is empty, use first nonzero bin
        ref_idx = 0
        if dV_th[0] == 0:
            ref_idx = np.where(nonzero_mask)[0][0] if np.any(nonzero_mask) else 0
        
        if dV_th[ref_idx] > 0:
            dist[nonzero_mask] = (core[nonzero_mask] * 
                                  np.sqrt(dV_th[ref_idx]) * 
                                  np.sqrt(dV_th[nonzero_mask]))
    
    return dist, th_centers, dV_th


def get_matrix_files(matrix_dir=MATRIX_DIR):
    """
    Get list of matrix files without loading them.
    Returns: list of (Theta, filename) tuples sorted by Theta
    """
    pattern = os.path.join(matrix_dir, "M_Iee_N*_dp*_T*.pkl")
    files = glob.glob(pattern)
    
    if not files:
        raise FileNotFoundError(f"No matrix files found in {matrix_dir}. Pattern: {pattern}")
    
    # Extract Theta from each file and sort
    files_with_theta = []
    for fname in files:
        try:
            # Load just metadata to get Theta
            with open(fname, 'rb') as fp:
                M_sparse, meta = pickle.load(fp)
            Theta = float(meta["Theta"])
            files_with_theta.append((Theta, fname))
        except Exception as e:
            print(f"Error reading {fname}: {e}", flush=True)
            continue
    
    # Sort by Theta
    files_with_theta.sort(key=lambda x: x[0])
    return files_with_theta


def load_single_matrix(fname):
    """
    Load a single matrix file.
    Returns: (matrix, meta) tuple
    """
    with open(fname, 'rb') as fp:
        M_sparse, meta = pickle.load(fp)
    
    Theta = float(meta["Theta"])
    
    # Keep matrix as-is (sparse or dense) - don't convert large sparse to dense
    # The compute function will handle it appropriately
    return M_sparse, meta


def compute_eigenvalue_from_eigenfunction(Ma, meta, eigenfunction, m):
    """
    Compute eigenvalue from eigenfunction using the Rayleigh quotient.
    
    For collision operator: -M v = gamma W v
    The eigenvalue is: gamma = (v^T (-M) v) / (v^T W v)
    """
    w_active = meta["w_active"].astype(np.float64)
    w_safe = np.clip(w_active, 1e-30, None)
    
    # Collision operator: -M v = gamma W v
    A = -Ma if isinstance(Ma, csr_matrix) else csr_matrix(-Ma)
    
    # Compute numerator: v^T A v
    Av = A.dot(eigenfunction)
    numerator = np.dot(eigenfunction, Av)
    
    # Compute denominator: v^T W v
    Wv = w_safe * eigenfunction
    denominator = np.dot(eigenfunction, Wv)
    
    if abs(denominator) > 1e-30:
        gamma = numerator / denominator
    else:
        gamma = 0.0
    
    return float(gamma)


def main():
    print("=== Eigenvalue / angular-distribution postprocessing (bruteforce) ===", flush=True)
    
    # Get list of matrix files (without loading them)
    files_with_theta = get_matrix_files()
    Thetas = [theta for theta, _ in files_with_theta]
    print(f"Found {len(files_with_theta)} matrix files", flush=True)
    print(f"Thetas={Thetas}", flush=True)
    print()
    
    # Step 1: Compute eigenfunctions for each temperature (process one at a time)
    print("=== Step 1: Computing eigenfunctions for each temperature ===", flush=True)
    all_eigenfunctions = {}
    all_eigenvalues_from_funcs = {}
    
    for Theta, fname in files_with_theta:
        print(f"\n[compute eigenfunctions] Theta={Theta:.6g}", flush=True)
        print(f"  Loading matrix from {os.path.basename(fname)}...", flush=True)
        
        # Load matrix for this temperature only
        Ma, meta = load_single_matrix(fname)
        print(f"  Matrix shape: {Ma.shape}, type: {type(Ma).__name__}", flush=True)
        
        # Compute eigenfunctions for angular modes
        eigenfunctions, eigenvalues, px, py = compute_eigenfunctions_by_mode(Ma, meta, ms=ms)
        
        # Store results (these are small compared to matrices)
        all_eigenfunctions[Theta] = eigenfunctions
        all_eigenvalues_from_funcs[Theta] = eigenvalues
        
        # Skip eigenfunction plotting to save time - only compute eigenvalues
        # plot_eigenfunctions_by_mode(eigenfunctions, eigenvalues, px, py, Theta, ms=ms,
        #                            save_prefix=f"eigenfunction_mode_T{Theta:.10g}",
        #                            show_plot=True)
        
        # Free memory - delete matrix
        del Ma, meta
        import gc
        gc.collect()
    
    # Step 2: Extract eigenvalues from eigenfunctions and plot vs T
    print("\n=== Step 2: Extracting eigenvalues from eigenfunctions ===", flush=True)
    eigs = {}
    
    for Theta in Thetas:
        print(f"[extract eigenvalues] Theta={Theta:.6g}", flush=True)
        eigenfunctions = all_eigenfunctions[Theta]
        
        eigs[Theta] = {}
        for m in ms:
            if eigenfunctions.get(m) is not None:
                # Use eigenvalue computed from eigenfunction
                eigs[Theta][m] = all_eigenvalues_from_funcs[Theta][m]
            else:
                eigs[Theta][m] = 0.0
    
    # ---- Plot eigenvalues as in original script (Figure-1 style) ----
    f10, ax10 = plt.subplots(figsize=(8*0.9, 6*0.9))
    
    for m in ms:
        y = []
        y0 = []
        for Theta in Thetas:
            y.append(eigs[Theta][m])
            if k == 0:
                y0.append(eigs[Theta][0])
            else:
                y0.append(eigs[Theta][1])
        
        power = 2  # same choices as original
        
        # Only plot m != 0,1 prominently (same logic as original code)
        if k == 0 and m != 0 and m != 1:
            # Filter out invalid values
            y_arr = np.array(y)
            y0_arr = np.array(y0)
            Thetas_arr = np.array(Thetas)
            valid = (y_arr - y0_arr) > 0
            log_thetas = np.array([])
            log_vals = np.array([])
            if np.any(valid):
                log_thetas = np.log(Thetas_arr[valid])
                log_vals = 3*np.log(2*np.pi) + np.log((y_arr[valid] - y0_arr[valid])/(Thetas_arr[valid]**power))
                # Only plot if we have enough points
                if len(log_vals) > 6:
                    ax10.plot(log_thetas[6:], log_vals[6:],
                              label=f"m = {m}", linewidth=1.5)
            
            if len(log_vals) > 6:
                print(f"m={m}", log_thetas[6:], log_vals[6:])
            else:
                print(f"m={m} [] []")
    
    # m=1 dashed special line (as in original)
    if k == 0:
        m = 1
        y = []
        y0 = []
        for Theta in Thetas:
            y.append(eigs[Theta][m])
            y0.append(eigs[Theta][0])
        power = 2
        y_arr = np.array(y)
        y0_arr = np.array(y0)
        Thetas_arr = np.array(Thetas)
        valid = (y_arr - y0_arr) > 0
        if np.any(valid):
            log_thetas = np.log(Thetas_arr[valid])
            log_vals = 3*np.log(2*np.pi) + np.log((y_arr[valid] - y0_arr[valid])/(Thetas_arr[valid]**power))
            if len(log_vals) > 5:
                ax10.plot(log_thetas[5:], log_vals[5:],
                          label="m = 1", linestyle="--", linewidth=1.5, color="gray")
                print("m=1", log_thetas[5:], log_vals[5:])
    
    # Reference lines (same as original)
    x_ref = np.linspace(-4.7, -3.0, 100)
    y_center = (2.2 + (-3.0)) / 2
    x_center = -3.0
    
    # x_ref = np.linspace(-4.7, -3.0, 100)
    # y_ref_2 = 1.9 + 0.0 * (x_ref - x_center)
    # ax10.plot(x_ref, y_ref_2, 'r--', alpha=0.6, linewidth=1.5, label=r'$T^2$')
    
    # x_ref = np.linspace(-4.7, -3.0, 100)
    # y_ref_33 = 0.68 + 1.3 * (x_ref - x_center)
    # ax10.plot(x_ref, y_ref_33, 'b-.', alpha=0.6, linewidth=1.5, label=r'$T^{3.3}$')
    
    # x_ref = np.linspace(-4.5, -3, 100)
    # y_ref_39 = y_center + 1.9 * (x_ref - x_center)
    # ax10.plot(x_ref, y_ref_39, 'm:', alpha=0.6, linewidth=1.5, label=r'$T^{3.9}$')
    
    # x_ref = np.linspace(-4.7, -2.0, 100)
    # y_ref_4 = -3 + 2.0 * (x_ref - x_center)
    # ax10.plot(x_ref, y_ref_4, 'g:', alpha=0.6, linewidth=2, label=r'$T^4$')
    
    # ax10.set_xlim(-4.7, 0.5)
    # ax10.set_ylim(-3.0, 2.2)
    ax10.set_xlabel(r'Temperature, $\ln (T/T_F)$')
    ax10.set_ylabel(r'Eigenvalues, $\ln(\lambda_m T_F^2/T^2)$')
    ax10.legend()
    
    f10.tight_layout()
    # Save eigenvalue plot
    f10.savefig('./Eigenvals_bruteforce.png', dpi=300, bbox_inches='tight')
    print("Saved: ./Eigenvals_bruteforce.png", flush=True)
    
    # Save eigenvalues to CSV file for later recreation
    print("\n=== Saving eigenvalues to CSV file ===", flush=True)
    import csv
    
    csv_filename = './Eigenvals_bruteforce.csv'
    with open(csv_filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        
        # Write header: T, m0, m1, m2, ...
        header = ['T'] + [f'm{m}' for m in ms]
        writer.writerow(header)
        
        # Write data rows
        for Theta in Thetas:
            row = [Theta] + [eigs[Theta][m] for m in ms]
            writer.writerow(row)
    
    print(f"Saved: {csv_filename}", flush=True)
    print(f"  Thetas: {len(Thetas)} values, range [{min(Thetas):.6g}, {max(Thetas):.6g}]", flush=True)
    print(f"  Modes: {ms}", flush=True)
    print(f"  Total rows: {len(Thetas)}", flush=True)
    
    plt.show()


def compute_eigenfunctions(Ma, meta, n_eigs=10):
    """
    Compute eigenvalues and eigenvectors of the collision operator.
    
    The collision operator is typically solved as a generalized eigenvalue problem:
    -M v = gamma W v, where W = diag(f(1-f)) is the weight matrix.
    
    Returns:
        eigenvalues: array of eigenvalues (decay rates)
        eigenvectors: array of eigenvectors (eigenfunctions) in active subspace
        px, py: momentum coordinates for active states
    """
    # Get weight matrix W = diag(f(1-f)) from metadata
    w_active = meta["w_active"].astype(np.float64)
    w_safe = np.clip(w_active, 1e-30, None)  # Avoid zeros
    
    # Build weight matrix
    W = diags(w_safe, 0, format="csr")
    
    # Collision operator: -M v = gamma W v
    # So we solve: (-M) v = gamma W v
    A = -Ma if isinstance(Ma, csr_matrix) else csr_matrix(-Ma)
    
    # Add tiny regularization to help convergence (if needed)
    n = A.shape[0]
    if REG_ABS > 0.0:
        A = A + diags([REG_ABS] * n, 0, format="csr")
    
    # Transform to symmetric problem: B = W^{-1/2} A W^{-1/2}
    # Then solve: B y = gamma y, and recover v = W^{-1/2} y
    w_inv_sqrt = 1.0 / np.sqrt(w_safe)
    Dinv_sqrt = diags(w_inv_sqrt, 0, format="csr")
    B = Dinv_sqrt @ A @ Dinv_sqrt
    
    # Check symmetry
    sym_err = np.abs((B - B.T).data).max() / (np.abs(B.data).max() + 1e-30) if B.nnz > 0 else 0.0
    
    n_eigs = min(n_eigs, n - 2)  # Can't compute more than n-1 eigenvalues
    
    if sym_err < 1e-8 and n_eigs > 0:
        # Use symmetric solver
        try:
            vals, y = eigsh(
                B,
                k=n_eigs,
                sigma=1e-10,
                which="LM",  # Largest magnitude (smallest decay rates)
                tol=1e-8,
                maxiter=20000
            )
            # Recover eigenvectors: v = W^{-1/2} y
            vecs = (Dinv_sqrt @ y).astype(np.float64)
        except Exception as e:
            print(f"Warning: eigsh failed ({e}), trying eigs...", flush=True)
            vals, vecs = eigs(
                A,
                M=W,
                k=n_eigs,
                sigma=1e-10,
                which="LM",
                tol=1e-8,
                maxiter=20000
            )
            vals = np.real(vals)
            vecs = np.real(vecs)
    else:
        # Non-symmetric fallback
        print(f"Warning: Matrix not symmetric (error={sym_err:.3e}), using non-symmetric solver", flush=True)
        vals, vecs = eigs(
            A,
            M=W,
            k=n_eigs,
            sigma=1e-10,
            which="LM",
            tol=1e-8,
            maxiter=20000
        )
        vals = np.real(vals)
        vecs = np.real(vecs)
    
    # Ensure real
    vals = np.real(vals)
    vecs = np.real(vecs)
    
    # Sort by eigenvalue (ascending = slowest decay first)
    order = np.argsort(vals)
    vals = vals[order]
    vecs = vecs[:, order]
    
    # Normalize in W-norm: v^T W v = 1
    for i in range(vecs.shape[1]):
        v = vecs[:, i]
        wv = w_safe * v
        norm_w = np.sqrt(np.dot(v, wv))
        if norm_w > 1e-30:
            vecs[:, i] = v / norm_w
    
    # Reconstruct px, py
    px, py = reconstruct_px_py(meta)
    
    return vals, vecs, px, py


def plot_eigenfunctions(vals, vecs, px, py, Theta, n_plot=6, save_prefix="eigenfunction"):
    """
    Plot eigenfunctions as 2D plots in (px, py) space.
    
    Args:
        vals: eigenvalues
        vecs: eigenvectors (columns)
        px, py: momentum coordinates
        Theta: temperature
        n_plot: number of eigenfunctions to plot
        save_prefix: prefix for saved files
    """
    n_plot = min(n_plot, vecs.shape[1])
    
    # Create figure with subplots
    n_cols = 3
    n_rows = (n_plot + n_cols - 1) // n_cols
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, 5*n_rows))
    # Ensure axes is always a 1D array
    if not isinstance(axes, np.ndarray):
        axes = np.array([axes])
    else:
        axes = axes.flatten()
    
    # Determine common color scale
    vmin_all = np.inf
    vmax_all = -np.inf
    for i in range(n_plot):
        v = vecs[:, i]
        vmin_all = min(vmin_all, v.min())
        vmax_all = max(vmax_all, v.max())
    
    # Use symmetric colormap centered at zero
    vmax_abs = max(abs(vmin_all), abs(vmax_all))
    vmin_plot = -vmax_abs
    vmax_plot = vmax_abs
    
    for i in range(n_plot):
        ax = axes[i]
        v = vecs[:, i]
        gamma = vals[i]
        
        # Create scatter plot colored by eigenfunction value
        scatter = ax.scatter(px, py, c=v, s=1, cmap='RdBu_r', 
                            vmin=vmin_plot, vmax=vmax_plot, alpha=0.6)
        
        ax.set_xlabel(r'$p_x$')
        ax.set_ylabel(r'$p_y$')
        ax.set_title(f'Eigenfunction {i+1}, γ={gamma:.6e}\nΘ={Theta:.6g}')
        ax.set_aspect('equal')
        ax.grid(True, alpha=0.3)
        
        # Add colorbar
        plt.colorbar(scatter, ax=ax, label='Eigenfunction value')
    
    # Hide unused subplots
    for i in range(n_plot, len(axes)):
        axes[i].set_visible(False)
    
    plt.tight_layout()
    
    # Save figure
    fname = f'{save_prefix}_T{Theta:.10g}.png'
    # plt.savefig(fname, dpi=150, bbox_inches='tight')
    print(f"Saved: {fname}", flush=True)
    # plt.show()
    plt.close()


def wdot(u, v, w):
    """Weighted inner product: u^T W v"""
    return float(np.dot(u, w * v))


def residual_B_from_u(A, w_safe, u, gamma):
    """Residual in B y = gamma y, where y = sqrt(W) u, B = W^{-1/2} A W^{-1/2}."""
    w_sqrt = np.sqrt(np.maximum(w_safe, 1e-300))
    w_inv_sqrt = 1.0 / w_sqrt

    y = w_sqrt * u
    Au = A.dot(u)
    By = w_inv_sqrt * Au

    num = np.linalg.norm(By - gamma * y)
    den = np.linalg.norm(By) + abs(gamma) * np.linalg.norm(y) + 1e-30
    return num / den


def build_constraints_y(w_safe, vecs_vspace):
    """
    Build constraint matrix Qy in y-space (columns orthonormal),
    where y = sqrt(W) v.
    """
    w_sqrt = np.sqrt(np.maximum(w_safe, 1e-300))
    Qy = w_sqrt[:, None] * np.column_stack(vecs_vspace)  # y-space constraints
    Qy, _ = np.linalg.qr(Qy)  # orthonormalize columns
    return Qy


def solve_smallest_mode_constrained(A, w_safe, y0, Qy, maxiter=8000, tol=1e-11):
    """
    Solve B y = gamma y for smallest gamma with constraints Qy,
    where B = W^{-1/2} A W^{-1/2}. Returns (gamma, u) with u in v-space.
    """
    w_safe = np.maximum(w_safe.astype(np.float64), 1e-30)
    w_inv_sqrt = 1.0 / np.sqrt(w_safe)

    D = diags(w_inv_sqrt, 0, format="csr")
    B = D @ A @ D
    B = 0.5 * (B + B.T)  # enforce symmetry numerically

    X = y0.reshape(-1, 1).astype(np.float64)
    if Qy is not None and Qy.size > 0:
        X = X - Qy @ (Qy.T @ X)

    # LOBPCG: smallest eigenpair under constraints
    vals, vecs = lobpcg(B, X, Y=Qy, largest=False, maxiter=maxiter, tol=tol)

    gamma = float(np.real(vals[0]))
    y = np.real(vecs[:, 0])

    # back to v-space: u = W^{-1/2} y
    u = w_inv_sqrt * y
    return gamma, u


def check_W_symmetry(A, w_safe, ntest=4, seed=0):
    """
    Cheap stochastic test of W-selfadjointness:
      <u, Av>_W = <Au, v>_W  <=>  B = W^{-1/2} A W^{-1/2} is symmetric.
    Returns (max_relative_asymmetry, mean_relative_asymmetry).
    """
    rng = np.random.default_rng(seed)
    w_sqrt = np.sqrt(w_safe)
    w_inv_sqrt = 1.0 / np.maximum(w_sqrt, 1e-300)

    def B_dot(y):
        # B y = W^{-1/2} A (W^{-1/2} y)
        u = w_inv_sqrt * y
        Au = A.dot(u)
        return w_inv_sqrt * Au

    rels = []
    for _ in range(ntest):
        x = rng.standard_normal(A.shape[0])
        y = rng.standard_normal(A.shape[0])
        Bx = B_dot(x)
        By = B_dot(y)
        lhs = float(np.dot(x, By))
        rhs = float(np.dot(Bx, y))
        denom = max(abs(lhs), abs(rhs), 1e-30)
        rels.append(abs(lhs - rhs) / denom)
    return max(rels), float(np.mean(rels))


def w_orthonormalize(vecs, w, remove_basis=None, drop_rel=1e-10):
    """
    W-orthonormalize a list of vectors, optionally removing projection onto a basis.
    
    Args:
        vecs: list of vectors to orthonormalize
        w: weight array (diagonal of weight matrix)
        remove_basis: optional list of vectors to remove projection onto
        drop_rel: relative threshold; vectors whose norm after projection
                  is <= drop_rel * original_norm are dropped instead of
                  being renormalized (prevents reinjecting invariants).
    
    Returns:
        list of W-orthonormal vectors
    """
    basis = []
    for v in vecs:
        u = v.astype(np.float64).copy()
        # Original norm before projections
        vnorm = np.sqrt(max(wdot(u, u, w), 0.0))
        # Remove projection onto remove_basis if provided
        if remove_basis is not None:
            for q in remove_basis:
                u -= wdot(q, u, w) * q
        # Remove projection onto previous basis vectors
        for q in basis:
            u -= wdot(q, u, w) * q
        # Normalize if not almost killed by projections
        nrm = np.sqrt(max(wdot(u, u, w), 0.0))
        if nrm > 1e-30 and nrm > drop_rel * (vnorm + 1e-300):
            basis.append(u / nrm)
    return basis


def wproj(u, v, w):
    """Projection coefficient of u onto v in W-inner product."""
    den = wdot(v, v, w) + 1e-300
    return wdot(v, u, w) / den


def wremove_span(u, span, w):
    """Remove W-orthogonal projection of u onto the span of vectors in span."""
    if span is None:
        return u
    out = u.astype(np.float64).copy()
    for q in span:
        out -= wproj(out, q, w) * q
    return out


def project_out(u, basis, w):
    """Project u orthogonal to a W-orthonormal basis (list of vectors)."""
    if basis is None:
        return u
    uu = u.astype(np.float64).copy()
    for q in basis:
        uu -= wdot(q, uu, w) * q
    return uu


def reconstruct_eps_and_vg(P, theta, meta):
    """
    Reconstruct single-particle energy eps(P) and group velocity magnitude v_g(P)
    in the same units used by the generator.
    """
    band = meta.get("band", "")
    if band == "bilayer_sqrt_vk_U":
        V_bar = float(meta["V_bar"])
        U_bar = float(meta["U_bar"])
        eps = np.sqrt((V_bar * P) ** 2 + (U_bar ** 2)) - U_bar
        denom = np.sqrt((V_bar * P) ** 2 + (U_bar ** 2))
        vg = (V_bar ** 2) * P / np.maximum(denom, 1e-30)
    else:
        # Fallback: simple parabolic spectrum eps = P^2
        eps = P * P
        vg = 2.0 * P
    vx = vg * np.cos(theta)
    vy = vg * np.sin(theta)
    return eps, vg, vx, vy


def wmean(x, w):
    """Weighted mean with respect to diagonal weight w."""
    num = float(np.dot(w * x, np.ones_like(x)))
    den = float(np.dot(w, np.ones_like(w))) + 1e-300
    return num / den


def build_hg_basis(z, m, theta, K, wtype="both"):
    """
    Hermite-Gauss radial basis:
      phi_k(z) = H_k(z) * exp(-z^2/2)
    multiplied by cos(m theta), sin(m theta).
    This captures sign-changing radial structure efficiently around the Fermi shell,
    which is crucial for odd-m modes at low T.
    """
    g = np.exp(-0.5 * z * z)
    basis = []
    for k in range(K):
        coeff = np.zeros(k + 1)
        coeff[-1] = 1.0
        Hk = hermval(z, coeff)
        rk = Hk * g
        if wtype in ("cos", "both"):
            basis.append(rk * np.cos(m * theta))
        if wtype in ("sin", "both"):
            basis.append(rk * np.sin(m * theta))
    return basis


def build_invariants(px, py, eps, w):
    """
    Build invariant constraint matrix in y-space (for B = W^{-1/2} A W^{-1/2}):
      Qy has columns corresponding to density, centered energy, px, py.
    Returns (Qy, eps_c) where eps_c is the centered energy in W-weight.
    """
    n = len(w)
    ones = np.ones(n, dtype=np.float64)

    w_safe = np.clip(w.astype(np.float64), 1e-30, None)
    # Center energy in W-weight
    ebar = float(np.dot(w_safe, eps)) / (float(np.dot(w_safe, ones)) + 1e-30)
    eps_c = (eps - ebar).astype(np.float64)

    Q = np.column_stack(
        [ones, eps_c, px.astype(np.float64), py.astype(np.float64)]
    )

    sw = np.sqrt(w_safe)
    Qy = sw[:, None] * Q

    # Orthonormalize constraints
    Qy, _ = np.linalg.qr(Qy)
    return Qy, eps_c


def low_modes_constrained(A, w, k=24, Qy=None, maxiter=3000, tol=1e-10, seed=0):
    """
    Solve B y = lambda y for the smallest lambdas with constraints Qy:
      B = W^{-1/2} A W^{-1/2}, A symmetric (or symmetrized) collision operator.
    Returns eigenvalues (lambda) and eigenvectors v in the original v-space
    related by v = W^{-1/2} y.
    """
    n = A.shape[0]
    w_safe = np.clip(w.astype(np.float64), 1e-30, None)

    winv_sqrt = 1.0 / np.sqrt(w_safe)
    D = diags(winv_sqrt, 0, format="csr")
    B = D @ A @ D
    # Explicit symmetrization helps lobpcg robustness
    B = 0.5 * (B + B.T)

    rng = np.random.default_rng(seed)
    X = rng.standard_normal((n, k)).astype(np.float64)

    # Project initial guess orthogonal to constraints
    if Qy is not None and Qy.size > 0:
        X = X - Qy @ (Qy.T @ X)

    vals, vecs = lobpcg(
        B,
        X,
        Y=Qy if (Qy is not None and Qy.size > 0) else None,
        tol=tol,
        maxiter=maxiter,
        largest=False,
    )

    idx = np.argsort(vals)
    vals = np.real(vals[idx])
    vecs = np.real(vecs[:, idx])

    # Back to v-space: v = W^{-1/2} y
    v = (winv_sqrt[:, None] * vecs).astype(np.float64)
    return vals, v

def angular_power(u, theta, w_safe, m_max=10):
    """Return normalized angular power spectrum P[m] for u (W-weighted)."""
    w_safe = np.maximum(w_safe.astype(np.float64), 1e-30)
    Pm = np.zeros(m_max + 1, dtype=np.float64)
    # complex Fourier coefficient for each m
    for m in range(m_max + 1):
        c = np.sum(w_safe * u * np.exp(-1j * m * theta))
        Pm[m] = (c.real * c.real + c.imag * c.imag)
    s = Pm.sum() + 1e-300
    return Pm / s


def classify_by_m(v, theta, w, m_max=12):
    """
    Classify each eigenvector v[:, j] by dominant angular harmonic m using
    weighted Fourier power in the W-inner product.
    Returns list of (m_dom, power) for each column of v.
    """
    w_safe = np.clip(w.astype(np.float64), 1e-30, None)
    out = []
    for j in range(v.shape[1]):
        u = v[:, j]
        best_m = 0
        best_pow = -1.0
        for m in range(m_max + 1):
            c = np.sum(w_safe * u * np.exp(-1j * m * theta))
            p = (c.real * c.real + c.imag * c.imag)
            if p > best_pow:
                best_pow = p
                best_m = m
        out.append((best_m, best_pow))
    return out


def diagnose_low_modes(Ma, meta, k=30, m_max=10, maxiter=5000, tol=1e-10, seed=0):
    """
    Diagnostic helper: compute constrained low-lying modes of the full operator
    and classify them by dominant angular harmonic m.
    Prints gamma, residual, and dominant m for the first few modes.
    """
    w = meta["w_active"].astype(np.float64)
    w_safe = np.clip(w, 1e-30, None)

    px, py = reconstruct_px_py(meta)
    theta = np.arctan2(py, px)
    P = np.sqrt(px * px + py * py)

    # Reconstruct eps using the same bilayer dispersion as the generator
    eps = eps_from_meta(P, meta)

    Qy, eps_c = build_invariants(px, py, eps, w_safe)

    # Build A in active space
    if isinstance(Ma, csr_matrix):
        A = -Ma
    else:
        A = csr_matrix(-Ma)

    vals, vecs = low_modes_constrained(A, w_safe, k=k, Qy=Qy, maxiter=maxiter, tol=tol, seed=seed)

    # Residuals in generalized eigenform A v = gamma W v
    residuals = []
    for i in range(len(vals)):
        v = vecs[:, i]
        Av = A.dot(v)
        Wv = w_safe * v
        gamma = vals[i]
        num = np.linalg.norm(Av - gamma * Wv)
        den = np.linalg.norm(Av) + abs(gamma) * np.linalg.norm(Wv) + 1e-30
        residuals.append(num / den)

    classes = classify_by_m(vecs, theta, w_safe, m_max=m_max)

    n_print = min(12, len(vals))
    for i in range(n_print):
        m_dom, pow_m = classes[i]
        print(
            f"  [low-mode {i:02d}] gamma={vals[i]:.3e}  res={residuals[i]:.2e}  "
            f"m≈{m_dom}  pow={pow_m:.3e}",
            flush=True,
        )

    return vals, vecs, residuals, classes


def compute_eigenfunctions_by_mode(Ma, meta, ms=[0, 1, 2, 3, 4, 5, 6, 7, 8]):
    """
    Compute eigenfunctions for specific angular modes m on the Fermi ring.
    
    Uses harmonic projection to find eigenfunctions corresponding to each angular mode.
    
    Returns:
        eigenfunctions: dict mapping m -> eigenfunction vector
        eigenvalues: dict mapping m -> eigenvalue (decay rate)
        px, py: momentum coordinates
    """
    # Get weight matrix W = diag(f(1-f)) from metadata
    w_active = meta["w_active"].astype(np.float64)
    w_safe = np.clip(w_active, 1e-30, None)
    
    # Reconstruct px, py, and angles
    px, py = reconstruct_px_py(meta)
    theta = np.arctan2(py, px)
    P = np.sqrt(px * px + py * py)
    Theta = float(meta.get("Theta", 0.0))
    dp = float(meta.get("dp", 0.0))
    # --- Consistent energy & velocity (use meta keys U_bar,V_bar as generator does) ---
    eps_raw = eps_from_meta(P, meta)
    vg = vg_from_meta(P, meta)
    vx = vg * np.cos(theta)
    vy = vg * np.sin(theta)
    # W-centered energy (critical!)
    ebar = float(np.dot(w_safe, eps_raw)) / (float(np.dot(w_safe, np.ones_like(eps_raw))) + 1e-30)
    eps_c = (eps_raw - ebar).astype(np.float64)
    
    # Collision operator: -M v = gamma W v
    # Handle matrix conversion carefully to avoid memory issues
    if isinstance(Ma, csr_matrix):
        # Already sparse - just negate
        A = -Ma
    elif isinstance(Ma, np.ndarray):
        # Dense array - convert to sparse if large, otherwise keep dense
        if Ma.size > 1e8:  # Very large matrix
            # For very large dense matrices, convert to sparse first, then negate
            print(f"  [warning] Large dense matrix ({Ma.shape}), converting to sparse...", flush=True)
            Ma_sparse = csr_matrix(Ma)
            A = -Ma_sparse
            del Ma_sparse  # Free memory
        else:
            # Small enough to work with directly
            A = csr_matrix(-Ma)
    else:
        # Try to convert to sparse
        A = csr_matrix(-Ma)

    # Enforce symmetric operator for Ritz + residual (in weighted sense)
    A = 0.5 * (A + A.T)
    
    W = diags(w_safe, 0, format="csr")
    
    # Add tiny regularization (if needed)
    n = A.shape[0]
    if REG_ABS > 0.0:
        A = A + diags([REG_ABS] * n, 0, format="csr")
    
    # W-selfadjointness sanity check in B-space
    sym_max, sym_mean = check_W_symmetry(A, w_safe, ntest=6, seed=1)
    print(f"  [sanity] W-selfadjoint test: max={sym_max:.2e} mean={sym_mean:.2e}", flush=True)

    # Sanity check: verify momentum conservation
    Apx_norm = np.linalg.norm(A.dot(px))
    px_norm = np.linalg.norm(px)
    Apy_norm = np.linalg.norm(A.dot(py))
    py_norm = np.linalg.norm(py)
    print(f"  [sanity] ||A px||/||px|| = {Apx_norm/(px_norm + 1e-30):.6e}")
    print(f"  [sanity] ||A py||/||py|| = {Apy_norm/(py_norm + 1e-30):.6e}")
    # Sanity check: density and centered energy conservation quality
    ones_vec = np.ones_like(px, dtype=np.float64)
    Aones_rel = np.linalg.norm(A.dot(ones_vec)) / (np.linalg.norm(ones_vec) + 1e-30)
    Aeps_rel = np.linalg.norm(A.dot(eps_c)) / (np.linalg.norm(eps_c) + 1e-30)
    print(f"  [sanity] ||A 1||/||1||   = {Aones_rel:.6e}")
    print(f"  [sanity] ||A eps_c||/||eps_c|| = {Aeps_rel:.6e}")

    # --- Invariants: density and momentum always. Energy only if well conserved. ---
    ENERGY_LEAK_THR = 1e-10
    use_energy = (Aeps_rel < ENERGY_LEAK_THR)
    if not use_energy:
        print("  [sanity] energy NOT treated as invariant (too leaky)", flush=True)
    else:
        print("  [sanity] energy treated as invariant", flush=True)

    inv_vecs = [ones_vec, px.astype(np.float64).copy(), py.astype(np.float64).copy()]
    if use_energy:
        inv_vecs.insert(1, eps_c.astype(np.float64).copy())  # [1, eps_c, px, py]

    # W-orthonormalize invariants once
    inv_orth = w_orthonormalize(inv_vecs, w_safe, remove_basis=None)
    
    eigenfunctions = {}
    eigenvalues = {}
    
    # Helper for W-inner product / correlations (diagnostics)
    def wdot_loc(u, v, w):
        return float(np.dot(u, w * v))

    def wcorr(u, v, w):
        nu = math.sqrt(max(wdot_loc(u, u, w), 0.0))
        nv = math.sqrt(max(wdot_loc(v, v, w), 0.0))
        if nu * nv < 1e-300:
            return 0.0
        return wdot_loc(u, v, w) / (nu * nv)

    def gen_residual(A_loc, w_loc, u_loc, gamma_loc):
        Au_loc = A_loc.dot(u_loc)
        Wu_loc = w_loc * u_loc
        num_loc = np.linalg.norm(Au_loc - gamma_loc * Wu_loc)
        den_loc = np.linalg.norm(Au_loc) + abs(gamma_loc) * np.linalg.norm(Wu_loc) + 1e-30
        return num_loc / den_loc

    # m=1 tuning constants
    M1_OVERLAP_MIN = 0.25      # require current-like character
    M1_TARGET_RES  = 5e-2      # target residual for acceptable eigenpair

    for m in ms:
        if m == 0:
            # m=0: density zero mode (always conserved)
            u0 = inv_orth[0].copy() if len(inv_orth) > 0 else np.ones(n, dtype=np.float64)
            u0 /= math.sqrt(max(wdot_loc(u0, u0, w_safe), 1e-30))
            eigenfunctions[m] = u0
            eigenvalues[m] = 0.0
            print("  [m=0] gamma=0 (density invariant)")
            continue
        elif m == 1:
            ones = np.ones(n, dtype=np.float64)

            # Constraints: density + momentum (and energy only if you decide it’s “good enough”)
            cons_v = [ones, px.astype(np.float64), py.astype(np.float64)]
            Qy = build_constraints_y(w_safe, cons_v)

            # Build an initial block X with strong m=1 content (in y-space)
            # Use both current and pure angular m=1 shapes to avoid degeneracy issues.
            w_sqrt = np.sqrt(w_safe)
            X = np.column_stack([
                w_sqrt * vx,                 # current-like
                w_sqrt * vy,
                w_sqrt * np.cos(theta),      # pure m=1 angular
                w_sqrt * np.sin(theta),
                w_sqrt * (P - 1.0) * np.cos(theta),  # add some radial structure
                w_sqrt * (P - 1.0) * np.sin(theta),
            ]).astype(np.float64)

            # Project away constraints
            X = X - Qy @ (Qy.T @ X)

            # Drop nearly zero / linearly dependent columns and orthonormalize
            col_norms = np.linalg.norm(X, axis=0)
            max_norm = np.max(col_norms) if col_norms.size > 0 else 0.0
            if max_norm > 0.0:
                mask = col_norms > 1e-12 * max_norm
                X = X[:, mask]

            # If all columns were projected away, fall back to a random y0 orthogonal to Qy
            if X.shape[1] == 0:
                rng = np.random.default_rng(0)
                y0 = rng.standard_normal(w_safe.shape[0])
                y0 = y0 - Qy @ (Qy.T @ y0)
                y0_norm = np.linalg.norm(y0)
                if y0_norm < 1e-30:
                    # as a last resort, use vx
                    y0 = w_sqrt * vx
                    y0 = y0 - Qy @ (Qy.T @ y0)
                    y0_norm = np.linalg.norm(y0)
                if y0_norm > 0.0:
                    y0 /= y0_norm
                X = y0.reshape(-1, 1)

            # Orthonormalize initial block
            X, _ = np.linalg.qr(X)

            # Solve for a small batch of lowest modes
            w_inv_sqrt = 1.0 / np.sqrt(w_safe)
            D = diags(w_inv_sqrt, 0, format="csr")
            B = D @ A @ D
            B = 0.5 * (B + B.T)

            vals, vecs = lobpcg(
                B, X, Y=Qy, largest=False,
                maxiter=20000, tol=1e-12
            )

            # Back to v-space
            order = np.argsort(vals)
            vals = np.real(vals[order])
            vecs = np.real(vecs[:, order])
            U = (w_inv_sqrt[:, None] * vecs).astype(np.float64)  # columns are candidates u_i

            # Pick the first mode with dominant m=1 angular power
            best_i = None
            best_score = -1.0
            for i in range(min(U.shape[1], 12)):
                ui = U[:, i]
                # normalize
                ui /= math.sqrt(max(wdot_loc(ui, ui, w_safe), 1e-30))

                Pm = angular_power(ui, theta, w_safe, m_max=8)
                score = Pm[1]  # how “m=1” it is
                # also require it's not basically m=3 etc
                if score > best_score:
                    best_score = score
                    best_i = i

            gamma = float(max(vals[best_i], 0.0))
            u = U[:, best_i]
            u /= math.sqrt(max(wdot_loc(u, u, w_safe), 1e-30))

            print(f"  [m=1] picked mode i={best_i} gamma={gamma:.6e}  P1={best_score:.3f}", flush=True)
            
            Pm = angular_power(u, theta, w_safe, m_max=8)
            print("  [m=1] Pm[0..8] =", " ".join([f"{p:.2f}" for p in Pm]), flush=True)

        else:
            # m >= 2: use Hermite-Gauss radial basis (derivative-like around FS)
            # and adaptively grow K until the generalized residual is small.
            remove = inv_orth[:] if len(inv_orth) > 0 else None  # remove all invariants

            TARGET_RES = 5e-2
            K_LIST_EVEN = [6, 10, 14]
            K_LIST_ODD = [10, 14, 18, 24, 32, 40]

            best = None  # (residual, gamma, u, K_use, sigma_p)

            for K_use in (K_LIST_ODD if (m % 2 == 1) else K_LIST_EVEN):
                # Odd m: wider sigma_p to allow particle–hole cancellations,
                # even m: narrower is sufficient.
                if m % 2 == 1:
                    sigma_p = max(20.0 * (0.5 * Theta), 3.0 * dp, 1e-12)
                else:
                    sigma_p = max(3.0 * (0.5 * Theta), 2.0 * dp, 1e-12)

                z = (P - 1.0) / sigma_p
                basis = build_hg_basis(z, m, theta, K_use, wtype="both")

                U_list = w_orthonormalize(basis, w_safe, remove_basis=remove)
                if len(U_list) == 0:
                    continue

                U = np.column_stack(U_list)
                AU = A.dot(U)
                C = U.T @ AU
                C = 0.5 * (C + C.T)

                evals, evecs = np.linalg.eigh(C)
                evals = np.real(evals)
                if evals.size == 0 or not np.any(np.isfinite(evals)):
                    continue

                # Choose smallest non-negative eigenvalue in this subspace
                jloc = int(np.argmin(np.maximum(evals, 0.0)))
                gamma_try = float(max(evals[jloc], 0.0))
                u_try = (U @ evecs[:, jloc]).astype(np.float64)
                nrm_try = math.sqrt(max(wdot_loc(u_try, u_try, w_safe), 1e-30))
                u_try = u_try / nrm_try

                Au = A.dot(u_try)
                Wu = w_safe * u_try
                num = np.linalg.norm(Au - gamma_try * Wu)
                den = np.linalg.norm(Au) + abs(gamma_try) * np.linalg.norm(Wu) + 1e-30
                res = num / den

                best = (res, gamma_try, u_try, K_use, sigma_p)
                if res <= TARGET_RES:
                    break

            if best is None:
                print(f"  [m={m}] no valid basis")
                eigenfunctions[m] = None
                eigenvalues[m] = np.nan
                continue

            res, gamma, u, K_use, sigma_p = best
            resB = residual_B_from_u(A, w_safe, u, gamma)
            print(f"  [m={m}] gamma={gamma:.6e}, residual_A={res:.3e}, residual_B={resB:.3e}, K={K_use}, sigma_p={sigma_p:.3e}")

        # Normalize in W-norm
        nrm = math.sqrt(max(wdot_loc(u, u, w_safe), 0.0))
        if nrm > 1e-30:
            u = u / nrm

        eigenfunctions[m] = u
        eigenvalues[m] = gamma

        # Diagnostics: normalized correlations with invariants and current-like vectors
        ones = np.ones(n, dtype=np.float64)
        if m == 1:
            # For m=1, also report correlation with projected current jx,jy
            print(
                f"  [m={m}] corr: dens={wcorr(u, ones,w_safe):+.2e}  en={wcorr(u, eps_c,w_safe):+.2e}  "
                f"px={wcorr(u, px,w_safe):+.2e} py={wcorr(u, py,w_safe):+.2e}  "
                f"jx={wcorr(u, vx,w_safe):+.2e} jy={wcorr(u, vy,w_safe):+.2e}",
                flush=True,
            )
        else:
            print(
                f"  [m={m}] corr: dens={wcorr(u, ones,w_safe):+.2e}  en={wcorr(u, eps_c,w_safe):+.2e}  "
                f"px={wcorr(u, px,w_safe):+.2e} py={wcorr(u, py,w_safe):+.2e}  "
                f"vx={wcorr(u, vx,w_safe):+.2e} vy={wcorr(u, vy,w_safe):+.2e}",
                flush=True,
            )

        # Diagnostics: residuals of generalized eigenpair -M u = γ W u and symmetric B-problem
        Au = A.dot(u)
        Wu = w_safe * u
        resA = np.linalg.norm(Au - gamma * Wu) / (
            np.linalg.norm(Au) + abs(gamma) * np.linalg.norm(Wu) + 1e-30
        )
        resB = residual_B_from_u(A, w_safe, u, gamma)
        print(f"  [m={m}] residual_A={resA:.3e}  residual_B={resB:.3e}", flush=True)
    
    return eigenfunctions, eigenvalues, px, py


def plot_eigenfunctions_main(Theta=None, n_eigs=10, n_plot=6, use_angular_modes=True):
    """
    Main function to compute and plot eigenfunctions.
    
    Args:
        Theta: specific temperature to plot (if None, plot first available)
        n_eigs: number of eigenvalues to compute (if not using angular modes)
        n_plot: number of eigenfunctions to plot (if not using angular modes)
        use_angular_modes: if True, plot eigenfunctions for angular modes m=0,1,2,3,4,5
    """
    print("=== Computing and plotting eigenfunctions ===", flush=True)
    
    # Get matrix files
    files_with_theta = get_matrix_files()
    available_thetas = [theta for theta, _ in files_with_theta]
    
    if Theta is None:
        Theta = available_thetas[0]
        print(f"No Theta specified, using first available: {Theta:.6g}", flush=True)
    
    if Theta not in available_thetas:
        raise ValueError(f"Theta={Theta} not found. Available: {available_thetas}")
    
    # Find and load the specific matrix
    fname = next(fname for theta, fname in files_with_theta if theta == Theta)
    Ma, meta = load_single_matrix(fname)
    print(f"Computing eigenfunctions for Theta={Theta:.6g}, Nactive={len(meta['active'])}", flush=True)
    
    if use_angular_modes:
        # Compute eigenfunctions for specific angular modes
        ms = [0, 1, 2, 3, 4, 5, 6, 7, 8]
        eigenfunctions, eigenvalues, px, py = compute_eigenfunctions_by_mode(Ma, meta, ms=ms)
        
        # Plot eigenfunctions for each mode
        plot_eigenfunctions_by_mode(eigenfunctions, eigenvalues, px, py, Theta, ms=ms)
        
        return eigenfunctions, eigenvalues, px, py
    else:
        # Compute general eigenfunctions
        vals, vecs, px, py = compute_eigenfunctions(Ma, meta, n_eigs=n_eigs)
        
        print(f"Computed {len(vals)} eigenvalues:")
        print(f"  Range: γ_min = {vals[0]:.6e}, γ_max = {vals[-1]:.6e}")
        print(f"  First {min(5, len(vals))}: {vals[:min(5, len(vals))]}")
        
        # Plot eigenfunctions
        plot_eigenfunctions(vals, vecs, px, py, Theta, n_plot=n_plot)
        
        return vals, vecs, px, py


def plot_eigenfunctions_by_mode(eigenfunctions, eigenvalues, px, py, Theta, ms=[0, 1, 2, 3, 4, 5, 6, 7, 8], save_prefix="eigenfunction_mode", show_plot=True):
    """
    Plot eigenfunctions for specific angular modes m.
    
    Args:
        eigenfunctions: dict mapping m -> eigenfunction vector
        eigenvalues: dict mapping m -> eigenvalue
        px, py: momentum coordinates
        Theta: temperature
        ms: list of angular modes to plot
        save_prefix: prefix for saved files
        show_plot: whether to display the plot (default True)
    """
    # Filter out None eigenfunctions
    valid_ms = [m for m in ms if eigenfunctions.get(m) is not None]
    
    if len(valid_ms) == 0:
        print("No valid eigenfunctions to plot", flush=True)
        return
    
    # Create figure with subplots
    n_cols = 3
    n_rows = (len(valid_ms) + n_cols - 1) // n_cols
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, 5*n_rows))
    if not isinstance(axes, np.ndarray):
        axes = np.array([axes])
    else:
        axes = axes.flatten()
    
    # Determine common color scale
    vmin_all = np.inf
    vmax_all = -np.inf
    for m in valid_ms:
        v = eigenfunctions[m]
        vmin_all = min(vmin_all, v.min())
        vmax_all = max(vmax_all, v.max())
    
    # Use symmetric colormap centered at zero
    vmax_abs = max(abs(vmin_all), abs(vmax_all))
    vmin_plot = -vmax_abs
    vmax_plot = vmax_abs
    
    for idx, m in enumerate(valid_ms):
        ax = axes[idx]
        v = eigenfunctions[m]
        gamma = eigenvalues[m]
        
        # Create scatter plot colored by eigenfunction value
        scatter = ax.scatter(px, py, c=v, s=1, cmap='RdBu_r', 
                            vmin=vmin_plot, vmax=vmax_plot, alpha=0.6)
        
        ax.set_xlabel(r'$p_x$')
        ax.set_ylabel(r'$p_y$')
        ax.set_title(f'Angular mode m={m}, γ={gamma:.6e}\nΘ={Theta:.6g}')
        ax.set_aspect('equal')
        ax.grid(True, alpha=0.3)
        
        # Add colorbar
        plt.colorbar(scatter, ax=ax, label='Eigenfunction value')
    
    # Hide unused subplots
    for idx in range(len(valid_ms), len(axes)):
        axes[idx].set_visible(False)
    
    plt.tight_layout()
    
    # Save figure
    fname = f'{save_prefix}_T{Theta:.10g}.png'
    plt.savefig(fname, dpi=150, bbox_inches='tight')
    print(f"Saved: {fname}", flush=True)
    # if show_plot:
        # plt.show()
    plt.close()


if __name__ == "__main__":
    # Main workflow: 
    # 1. Plot eigenfunctions for each temperature
    # 2. Extract eigenvalues from eigenfunctions and plot vs temperature
    main()
