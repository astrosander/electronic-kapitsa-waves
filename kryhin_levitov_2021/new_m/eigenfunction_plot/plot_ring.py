# Integrals_eig_bruteforce.py
# Eigenvalue computation for matrices generated by Iee_matrix_bruteforce_generate.py

import os
import argparse
import numpy as np
import pickle
import threading
import time

from scipy.sparse import csr_matrix, diags
from scipy.sparse.linalg import eigsh, eigs
from scipy.linalg import eigh  # dense generalized eigen-solver for small Ritz problems

from matplotlib import pyplot as plt
import matplotlib
matplotlib.use("Agg")  # non-interactive backend

# -----------------------------
# Configuration
# -----------------------------
ms = [1]#,2,3,4]  # angular modes to extract

# Radial basis parameters (used for m>=2)
RADIAL_BASIS_K = 1000#12
# RADIAL_SIGMA_P_MULT = 3.0  # legacy (unused when BASIS_IN_X=True)
# RADIAL_MODE_INDEX = 0  # kept for compatibility, not used directly here

# NEW: build Ritz radial basis in x=(eps-1)/Theta as in the paper
BASIS_IN_X = True

# NEW: eigenvalue selection tolerance (exclude conserved/near-zero modes)
ZERO_EIG_ABS = 0#1e-14
ZERO_EIG_REL = 0#1e-12  # relative to max Ritz eigenvalue in subspace

COMPUTE_RAW_EIGENVECTORS = True
N_RAW_EIGS = 16
N_RAW_PLOT = 16

REG_ABS = 0.0  # do NOT add abs diagonal regularization when chasing tiny low-T rates
RING_PIXEL_SIZE = 200.0

# What to plot in the panels:
#   "eta"        -> plot eta (will show zebra stripes)
#   "deltaf"     -> plot deltaf = w * eta (usually smoother)
#   "eta_masked" -> plot eta but mask tiny-w region (cleaner)
PLOT_QUANTITY_BY_MODE = "eta"      # for M_Iee...svg/png
PLOT_QUANTITY_RAW     = "eta"      # for eigenvector_panel_raw.svg

# If RAW vectors you reconstruct behave like deltaf, you can convert to eta as v/(w+eps).
# This flag makes RAW zebra stripes appear even when raw vectors are deltaf-like.
# PATCH: In this code path, raw eigenvectors V returned from symmetrize_operator()
# are already eta (generalized eigenproblem C v = gamma W v). Dividing by w would
# plot eta/w which is NOT the eigenvector whose gamma is printed.
FORCE_RAW_ETA_BY_DIVIDING_W = False

# NEW: overlay p=1 ring on plots
OVERLAY_FERMI_RING = True

plt.rcParams["text.usetex"] = False
plt.rcParams["font.family"] = "serif"
plt.rcParams["legend.frameon"] = False

DEFAULT_MATRIX_FILE = r"D:\Рабочая папка\GitHub\electronic-kapitsa-waves\kryhin_levitov_2021\collision_integral_direct\Matrixes_bruteforce\M_Iee_nonparabolic_mu2.5_U1_N320_dp0.03_T0.04_Tphys0.1.pkl"#"D:\Рабочая папка\GitHub\electronic-kapitsa-waves\kryhin_levitov_2021\collision_integral_direct\Matrixes_bruteforce\M_Iee_nonparabolic_mu2.5_U1_N320_dp0.03_T0.04_Tphys0.1.pkl"


# -----------------------------
# Utilities: W-inner products etc.
# -----------------------------
def wdot(u, v, w):
    """Weighted dot: u^T diag(w) v"""
    return float(np.dot(u, w * v))

def wnorm(u, w):
    """Weighted norm: sqrt(u^T diag(w) u)"""
    return float(np.sqrt(max(wdot(u, u, w), 0.0)))

def normalize_W(v, W):
    """Normalize by W-norm. W can be sparse diagonal or 1D diag array."""
    if hasattr(W, "diagonal"):
        w = W.diagonal()
    else:
        w = W
    n = wnorm(v, w)
    return v / (n + 1e-300)

def rayleigh_gamma(C, W, v):
    """gamma = (v^T C v) / (v^T W v), W can be sparse diagonal matrix"""
    Cv = C @ v
    num = float(v @ Cv)
    if hasattr(W, "diagonal"):
        w = W.diagonal()
        den = float(np.dot(v, w * v)) + 1e-300
    else:
        den = float(np.dot(v, W * v)) + 1e-300
    return num / den

def eigen_residual_rel(C, W, v, gamma=None):
    """||C v - gamma W v||_W / ||C v||_W"""
    if gamma is None:
        gamma = rayleigh_gamma(C, W, v)

    Cv = C @ v
    if hasattr(W, "diagonal"):
        w = W.diagonal()
        Wv = w * v
    else:
        Wv = W * v

    r = Cv - gamma * Wv

    if hasattr(W, "diagonal"):
        w = W.diagonal()
        denom = wnorm(Cv, w)
        if denom < 1e-300:
            return np.inf
        return wnorm(r, w) / denom
    else:
        # if W is a vector, treat it as diagonal
        denom = wnorm(Cv, W)
        if denom < 1e-300:
            return np.inf
        return wnorm(r, W) / denom

def symmetrize_operator(C, w_diag):
    """
    Build A = W^{-1/2} C W^{-1/2} with W = diag(w_diag).
    Returns (A, apply_Winv_sqrt)
    """
    w = np.asarray(w_diag, dtype=np.float64)
    w = np.clip(w, 1e-30, None)
    winv_sqrt = 1.0 / np.sqrt(w)

    def apply_Winv_sqrt(x):
        return winv_sqrt * x

    if not isinstance(C, csr_matrix):
        C = csr_matrix(C)
    A = diags(winv_sqrt, 0, format="csr") @ C @ diags(winv_sqrt, 0, format="csr")
    return A, apply_Winv_sqrt

def reconstruct_eps_active(meta, px, py):
    """
    Prefer eps_active saved by generator. Fallback: recompute eps(p) from meta.
    eps is dimensionless with eps(pF)=1.
    """
    if "eps_active" in meta:
        return np.asarray(meta["eps_active"], dtype=np.float64)

    # Fallback recompute from dispersion metadata
    P = np.sqrt(px*px + py*py)
    disp = str(meta.get("dispersion", "parabolic"))
    alpha = float(meta.get("alpha", 0.0))
    if disp == "parabolic":
        return P*P
    if disp == "nonparabolic":
        a = alpha
        return np.sqrt(a*a + (1.0 + 2.0*a)*(P*P)) - a
    raise ValueError(f"Unknown dispersion={disp!r} and eps_active not provided.")


# -----------------------------
# Lattice reconstruction
# -----------------------------
def build_centered_lattice(Nmax: int):
    half = Nmax // 2
    ns = np.arange(-half, half, dtype=np.int32)
    nx, ny = np.meshgrid(ns, ns, indexing="ij")
    return nx.reshape(-1), ny.reshape(-1), half

def reconstruct_px_py(meta):
    Nmax = int(meta["Nmax"])
    dp = float(meta["dp"])
    active = meta["active"].astype(np.int32)

    half = int(meta["half"])  # saved by generator
    shift_x = float(meta.get("shift_x", 0.0))
    shift_y = float(meta.get("shift_y", 0.0))

    nx_full, ny_full, _ = build_centered_lattice(Nmax)
    nx = nx_full[active].astype(np.float64)
    ny = ny_full[active].astype(np.float64)

    px = dp * (nx + shift_x)
    py = dp * (ny + shift_y)
    return px, py


# -----------------------------
# Progress printer for long eigsh/eigs
# -----------------------------
class ProgressPrinter:
    def __init__(self, message, interval=30, matrix_size=None, n_eigs=1):
        self.message = message
        self.interval = interval
        self.matrix_size = matrix_size
        self.n_eigs = n_eigs
        self.stop_flag = threading.Event()
        self.thread = None

        if matrix_size is not None:
            if matrix_size < 5000:
                self.estimated_min, self.estimated_max = 120, 300
            elif matrix_size < 10000:
                self.estimated_min, self.estimated_max = 300, 900
            elif matrix_size < 20000:
                self.estimated_min, self.estimated_max = 900, 1800
            else:
                self.estimated_min, self.estimated_max = 1800, 3600
            self.estimated_min *= (1 + 0.3 * (n_eigs - 1))
            self.estimated_max *= (1 + 0.3 * (n_eigs - 1))
        else:
            self.estimated_min, self.estimated_max = None, None

    def _print_progress(self):
        start_time = time.time()
        while not self.stop_flag.is_set():
            elapsed = time.time() - start_time

            if self.estimated_min is not None:
                estimated_avg = 0.5 * (self.estimated_min + self.estimated_max)
                progress_pct = min(95.0, 100.0 * elapsed / (estimated_avg + 1e-9))
                if elapsed < estimated_avg:
                    rem = estimated_avg - elapsed
                    if rem < 60:
                        rem_str = f"{rem:.0f}s"
                    elif rem < 3600:
                        rem_str = f"{rem/60:.1f}min"
                    else:
                        rem_str = f"{rem/3600:.1f}hr"
                else:
                    rem_str = "unknown"

                elapsed_str = f"{elapsed/60:.1f}min" if elapsed >= 60 else f"{elapsed:.0f}s"
                print(f"  [PROGRESS] {self.message} | elapsed: {elapsed_str} | progress: ~{progress_pct:.1f}% | est. remaining: {rem_str}", flush=True)
            else:
                elapsed_str = f"{elapsed/60:.1f}min" if elapsed >= 60 else f"{elapsed:.0f}s"
                print(f"  [PROGRESS] {self.message} | elapsed: {elapsed_str}", flush=True)

            if self.stop_flag.wait(self.interval):
                break

    def start(self):
        self.thread = threading.Thread(target=self._print_progress, daemon=True)
        self.thread.start()

    def stop(self):
        self.stop_flag.set()
        if self.thread:
            self.thread.join(timeout=1.0)


# -----------------------------
# Conservation residuals
# -----------------------------
def print_conservation_residuals(Ma, meta, px, py):
    w = np.clip(meta["w_active"].astype(np.float64), 1e-30, None)
    A = -Ma if isinstance(Ma, csr_matrix) else csr_matrix(-Ma)

    ones = np.ones(A.shape[0], dtype=np.float64)
    eps_a = reconstruct_eps_active(meta, px, py)
    e_shift = eps_a - 1.0
    cands = {
        "eta:1":   ones,
        "eta:px":  px,
        "eta:py":  py,
        "eta:eps": e_shift,
        "df:w":    w,
        "df:wpx":  w * px,
        "df:wpy":  w * py,
        "df:weps": w * e_shift,
    }

    scale = float(np.max(np.abs(A.data)) + 1e-30)
    print("\n=== Conservation residuals (relative) ===", flush=True)
    for name, v in cands.items():
        r = A.dot(v)
        rel = np.linalg.norm(r) / (np.linalg.norm(v) * scale + 1e-30)
        print(f"{name:8s}  rel_resid = {rel:.3e}", flush=True)
    print("=========================================\n", flush=True)


# -----------------------------
# Raw (general) eigenfunctions
# -----------------------------
def compute_general_eigenfunctions(Ma, meta, n_eigs=16, tol=1e-8, maxiter=20000):
    print(f"  [compute_general_eigenfunctions] Starting, n_eigs={n_eigs}...", flush=True)

    w = np.clip(meta["w_active"].astype(np.float64), 1e-30, None)
    W = diags(w, 0, format="csr")

    C = -Ma if isinstance(Ma, csr_matrix) else csr_matrix(-Ma)  # same convention as elsewhere

    n = C.shape[0]
    print(f"  [compute_general_eigenfunctions] Matrix size: {n}x{n}", flush=True)

    if REG_ABS > 0.0:
        C = C + diags([REG_ABS] * n, 0, format="csr")

    print("  [compute_general_eigenfunctions] Transforming to symmetric form...", flush=True)
    A_sym, Winv_sqrt = symmetrize_operator(C, w)

    # symmetry check
    sym_err = 0.0
    if A_sym.nnz > 0:
        diff = (A_sym - A_sym.T)
        sym_err = float(np.abs(diff.data).max() / (np.abs(A_sym.data).max() + 1e-30)) if diff.nnz > 0 else 0.0

    n_eigs = min(n_eigs, max(n - 2, 1))

    tol_fast = 1e-6 if n > 10000 else tol
    maxiter_fast = 5000 if n > 10000 else maxiter

    if sym_err < 1e-8:
        print(f"  [compute_general_eigenfunctions] Solving with eigsh (which='SM', tol={tol_fast:.1e}, maxiter={maxiter_fast})...", flush=True)
        print("  [compute_general_eigenfunctions] WARNING: which='SM' can be slow for large matrices.", flush=True)

        progress = ProgressPrinter("eigsh still running...", interval=30, matrix_size=n, n_eigs=n_eigs)
        progress.start()
        try:
            evals_sym, U = eigsh(A_sym, k=n_eigs, which="SM", tol=tol_fast, maxiter=maxiter_fast)
        finally:
            progress.stop()

        # Convert back: v = W^{-1/2} u
        V = np.zeros_like(U)
        for i in range(U.shape[1]):
            V[:, i] = Winv_sqrt(U[:, i])

        print("  [compute_general_eigenfunctions] eigsh completed successfully", flush=True)
    else:
        print(f"Warning: Symmetry error={sym_err:.3e}, falling back to eigs generalized solve", flush=True)
        progress = ProgressPrinter("eigs still running...", interval=30, matrix_size=n, n_eigs=n_eigs)
        progress.start()
        try:
            evals_sym, V = eigs(C, M=W, k=n_eigs, which="SM", tol=tol_fast, maxiter=maxiter_fast)
        finally:
            progress.stop()
        evals_sym = np.real(evals_sym)
        V = np.real(V)

    # Compute Rayleigh gammas in the SAME definition
    gammas = np.array([rayleigh_gamma(C, W, V[:, i]) for i in range(V.shape[1])])
    idx = np.argsort(gammas)
    gammas = gammas[idx]
    V = V[:, idx]
    evals_sym = np.real(evals_sym)[idx]

    res = np.array([eigen_residual_rel(C, W, V[:, i], gammas[i]) for i in range(V.shape[1])])

    px, py = reconstruct_px_py(meta)
    print("  [compute_general_eigenfunctions] Completed successfully", flush=True)
    return gammas, V, evals_sym, res, px, py


# -----------------------------
# m-mode eigenfunctions via generalized Ritz (correct)
# -----------------------------
def w_orthonormalize(vecs, w, remove_basis=None):
    basis = []
    for v in vecs:
        u = v.astype(np.float64).copy()

        if remove_basis is not None:
            for q in remove_basis:
                u -= wdot(q, u, w) * q

        for q in basis:
            u -= wdot(q, u, w) * q

        nrm = wnorm(u, w)
        if nrm > 1e-30:
            basis.append(u / nrm)
    return basis

def compute_eigenfunctions_by_mode(Ma, meta, ms):
    w = np.clip(meta["w_active"].astype(np.float64), 1e-30, None)
    W = diags(w, 0, format="csr")

    px, py = reconstruct_px_py(meta)
    theta = np.arctan2(py, px)
    P = np.sqrt(px * px + py * py)
    Theta = float(meta.get("Theta", 0.0))
    dp = float(meta.get("dp", 0.0))

    # NEW: energy variable x = (eps-1)/Theta as in the paper eigenproblem
    eps_a = reconstruct_eps_active(meta, px, py)
    if Theta <= 0:
        raise ValueError("Theta must be > 0 for x=(eps-1)/Theta basis.")
    x = (eps_a - 1.0) / Theta
    # Bounded coordinate improves numerical conditioning of polynomial basis
    y = np.tanh(0.5 * x)

    A = -Ma if isinstance(Ma, csr_matrix) else csr_matrix(-Ma)
    n = A.shape[0]
    if REG_ABS > 0.0:
        A = A + diags([REG_ABS] * n, 0, format="csr")

    # Build invariants basis (density, momentum, energy) and W-orthonormalize
    # These must be deflated for ALL m to avoid leakage on a discrete/truncated grid.
    inv_vecs = [
        np.ones(n, dtype=np.float64),
        px.copy(),
        py.copy(),
        (eps_a - 1.0).copy(),
    ]
    inv_orth = w_orthonormalize(inv_vecs, w)

    eigenfunctions = {}
    eigenvalues = {}

    for m in ms:
        if m == 0:
            u0 = inv_orth[0] if len(inv_orth) > 0 else np.ones(n) / np.sqrt(n)
            eigenfunctions[m] = u0
            eigenvalues[m] = 0.0
            print(f"  [m={m}] density mode: gamma=0.0 (conserved)", flush=True)
            continue

        # --- PATCH: always remove ALL conserved invariants for ALL m ---
        remove = []#inv_orth[:] if len(inv_orth) > 0 else None

        basis = []
        for kk in range(int(RADIAL_BASIS_K)):
            if BASIS_IN_X:
                rk = y ** kk  # bounded [-1,1], includes constant mode exactly at kk=0
                basis.append(rk * np.cos(m * theta))
                basis.append(rk * np.sin(m * theta))
            else:
                # legacy (P-based) basis
                sigma_p = max(RADIAL_SIGMA_P_MULT * (0.5 * Theta), 4.0 * dp, 1e-12)
                z = (P - 1.0) / sigma_p
                g = np.exp(-0.5 * z * z)
                rk = z ** kk
                basis.append(g * rk * np.cos(m * theta))
                basis.append(g * rk * np.sin(m * theta))

        U_list = w_orthonormalize(basis, w, remove_basis=remove)

        if len(U_list) == 0:
            print(f"  [m={m}] No valid basis, skipping", flush=True)
            eigenfunctions[m] = None
            eigenvalues[m] = np.nan
            continue

        U = np.column_stack(U_list)              # n x r
        AU = A.dot(U)                             # n x r
        WU = (w[:, None] * U)                     # n x r (since W is diagonal)

        # Generalized Ritz matrices
        K = U.T @ AU                              # r x r
        M = U.T @ WU                              # r x r

        # Symmetrize (numerical safety)
        K = 0.5 * (K + K.T)
        M = 0.5 * (M + M.T)

        # Solve K a = gamma M a
        evals, evecs = eigh(K, M)
        evals = np.real(evals)

        # keep finite
        mask = np.isfinite(evals)
        if not np.any(mask):
            print(f"  [m={m}] No valid eigenvalues after filtering", flush=True)
            eigenfunctions[m] = None
            eigenvalues[m] = np.nan
            continue

        evals = evals[mask]
        evecs = evecs[:, mask]

        # PATCH: pick smallest strictly-positive eigenvalue (exclude conserved/near-zero)
        tol = max(ZERO_EIG_ABS, ZERO_EIG_REL * float(np.max(np.abs(evals)) + 1e-300))
        pos_mask = evals > tol
        if not np.any(pos_mask):
            print(f"  [m={m}] Only (near-)zero modes found in Ritz space; increase RADIAL_BASIS_K or check truncation.", flush=True)
            eigenfunctions[m] = None
            eigenvalues[m] = np.nan
            continue

        evals_pos = evals[pos_mask]
        evecs_pos = evecs[:, pos_mask]
        j = int(np.argmin(evals_pos))
        a = evecs_pos[:, j]
        u = U @ a

        # Normalize and compute full Rayleigh gamma + residual
        u = normalize_W(u, W)
        gamma = rayleigh_gamma(A, W, u)
        res_m = eigen_residual_rel(A, W, u, gamma)

        # Sanity check for m=1 deflation (overlaps with momentum and energy should be ~0)
        # if m == 1:
        #     px_overlap = wdot(u, px, w)
        #     py_overlap = wdot(u, py, w)
        #     eps_overlap = wdot(u, eps_a - 1.0, w)
        #     print(f"    overlaps (W): <u,px>={px_overlap:.3e}  <u,py>={py_overlap:.3e}  <u,eps-1>={eps_overlap:.3e}", flush=True)

        eigenfunctions[m] = u
        eigenvalues[m] = gamma

        print(f"  [m={m}] gamma(Rayleigh,full)={gamma:.6e}  rel_resid={res_m:.3e}", flush=True)

    return eigenfunctions, eigenvalues, px, py


# -----------------------------
# Plotting helpers
# -----------------------------
def ring_scatter(ax, px, py, val, title=""):
    xs, ix = np.unique(px, return_inverse=True)
    ys, iy = np.unique(py, return_inverse=True)

    ny = len(ys)
    nx = len(xs)

    grid = np.full((ny, nx), np.nan, dtype=float)
    for k, (jx, jy) in enumerate(zip(ix, iy)):
        grid[jy, jx] = val[k]

    if np.all(~np.isfinite(grid)):
        vmax = 1.0
    else:
        vmax = float(np.nanmax(np.abs(grid)))
        if vmax <= 0 or not np.isfinite(vmax):
            vmax = 1.0

    vmin = -vmax

    dx = float(np.min(np.diff(xs))) if nx > 1 else 1.0
    dy = float(np.min(np.diff(ys))) if ny > 1 else 1.0

    extent = [xs[0] - dx/2, xs[-1] + dx/2, ys[0] - dy/2, ys[-1] + dy/2]

    cmap = plt.get_cmap("RdBu_r").copy()
    cmap.set_bad("white")

    im = ax.imshow(
        grid,
        origin="lower",
        cmap=cmap,
        vmin=vmin,
        vmax=vmax,
        extent=extent,
        interpolation="nearest",
        aspect="equal",
    )
    ax.set_title(title)
    ax.set_xticks([])
    ax.set_yticks([])
    
    # PATCH: overlay Fermi ring p=1
    if OVERLAY_FERMI_RING:
        t = np.linspace(0.0, 2.0*np.pi, 400)
        ax.plot(np.cos(t), np.sin(t), linewidth=0.8, color='black', alpha=0.5)
    
    return im

def choose_plot_field(v, w, quantity, force_eta_by_dividing_w=False):
    """
    v: vector in whatever coordinates you have
    w: diag weights f(1-f)

    quantity:
      - "eta"        : show eta. If force_eta_by_dividing_w=True, returns v/(w+eps).
      - "deltaf"     : show deltaf = w * eta. If force_eta_by_dividing_w=True, returns v (assuming v already deltaf).
      - "eta_masked" : eta but NaN where w is tiny.
    """
    eps = 1e-300
    wmax = np.max(w) + eps
    mask = w < 1e-6 * wmax

    if quantity == "eta":
        if force_eta_by_dividing_w:
            out = v / (w + eps)
        else:
            out = v
        return out

    if quantity == "deltaf":
        if force_eta_by_dividing_w:
            # if v is deltaf already, keep it
            out = v
        else:
            # if v is eta, convert to deltaf
            out = w * v
        return out

    if quantity == "eta_masked":
        if force_eta_by_dividing_w:
            out = v / (w + eps)
        else:
            out = v.copy()
        out = out.astype(float, copy=False)
        out[mask] = np.nan
        return out

    raise ValueError("quantity must be 'eta', 'deltaf', or 'eta_masked'")

def overlap_W(u, v, w):
    """Normalized absolute overlap |<u,v>_W| / (||u||_W ||v||_W)."""
    nu = wnorm(u, w)
    nv = wnorm(v, w)
    if nu < 1e-300 or nv < 1e-300:
        return 0.0
    return abs(wdot(u, v, w)) / (nu * nv)

def build_raw_matches_by_mode(eigenfunctions_by_m, raw_vecs, w):
    """
    For each raw eigenvector k, find best matching m-mode eigenvector by W-overlap.
    Returns list of dicts: [{"best_m": m, "overlap": ov}, ...] length = n_raw.
    """
    ms_available = [m for m, u in eigenfunctions_by_m.items() if u is not None]
    matches = []
    for k in range(raw_vecs.shape[1]):
        best_m = None
        best_ov = -1.0
        vk = raw_vecs[:, k]
        for m in ms_available:
            ov = overlap_W(eigenfunctions_by_m[m], vk, w)
            if ov > best_ov:
                best_ov = ov
                best_m = m
        matches.append({"best_m": best_m, "overlap": best_ov})
    return matches

def plot_eigenvector_panel(eigenfunctions, eigenvalues, px, py, Theta, ms, w, plot_quantity="eta"):
    valid_ms = [m for m in ms if eigenfunctions.get(m) is not None]
    if len(valid_ms) == 0:
        print("No valid eigenfunctions to plot", flush=True)
        return

    n_cols = 4
    n_rows = (len(valid_ms) + n_cols - 1) // n_cols
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(16, 4 * n_rows))
    axes = np.array([axes]) if not isinstance(axes, np.ndarray) else axes.flatten()

    for idx, m in enumerate(valid_ms):
        ax = axes[idx]
        v = eigenfunctions[m]
        gamma = eigenvalues[m]

        v_plot = choose_plot_field(v, w, plot_quantity, force_eta_by_dividing_w=False)
        ring_scatter(ax, px, py, v_plot, title=f"m={m}, γ={gamma:.6e}, Θ={Theta:.6g}")

    for idx in range(len(valid_ms), len(axes)):
        axes[idx].set_visible(False)

    fname_svg = f'{MATRIX_FILE.replace(".pkl", "")}.svg'
    fname_png = f'{MATRIX_FILE.replace(".pkl", "")}.png'
    plt.savefig(fname_svg, dpi=300, bbox_inches="tight")
    plt.savefig(fname_png, dpi=300, bbox_inches="tight")
    print(f"Saved: {fname_png}", flush=True)
    plt.close(fig)

def plot_general_eigenvector_panel(vals, vecs, px, py, Theta, w, n_plot=10, plot_quantity="eta",
                                   extra_items=None, raw_matches=None, filename="eigenvector_panel_raw.svg"):
    if vecs.size == 0:
        print("No general eigenvectors to plot", flush=True)
        return

    # extra_items: list of (label, gamma, vector) that will be plotted first
    if extra_items is None:
        extra_items = []

    n_raw = min(n_plot, vecs.shape[1])
    total = len(extra_items) + n_raw

    if raw_matches is None:
        raw_matches = [None] * n_raw

    n_cols = 4
    n_rows = (total + n_cols - 1) // n_cols
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(16, 4 * n_rows))
    axes = np.array([axes]) if not isinstance(axes, np.ndarray) else axes.flatten()

    slot = 0

    # ---- First: plot the m-projected (by-mode) eigenvectors in the SAME file ----
    for (label, gamma, v) in extra_items:
        ax = axes[slot]
        v_plot = choose_plot_field(v, w, plot_quantity, force_eta_by_dividing_w=False)
        ring_scatter(ax, px, py, v_plot, title=f"{label}\nγ={gamma:.6e}, Θ={Theta:.6g}")
        slot += 1

    # ---- Then: plot raw eigenvectors, but plot the SAME object that gamma refers to ----
    for i in range(n_raw):
        ax = axes[slot]
        v = vecs[:, i]
        gamma = vals[i]

        # PATCH: raw vecs here are eta; do NOT divide by w unless you *know* vecs are deltaf
        v_plot = choose_plot_field(v, w, plot_quantity, force_eta_by_dividing_w=FORCE_RAW_ETA_BY_DIVIDING_W)

        mi = raw_matches[i] if i < len(raw_matches) else None
        if mi is not None and mi.get("best_m") is not None:
            bm = mi["best_m"]
            ov = mi["overlap"]
            title = f"raw #{i+1}, γ={gamma:.6e}\nbest m={bm}, overlap={ov:.3f}, Θ={Theta:.6g}"
        else:
            title = f"raw #{i+1}, γ={gamma:.6e}, Θ={Theta:.6g}"

        ring_scatter(ax, px, py, v_plot, title=title)
        slot += 1

    for i in range(slot, len(axes)):
        axes[i].set_visible(False)

    # plt.suptitle("Combined: m-projected modes + raw eigenvectors", fontsize=14, fontweight="bold", y=0.995)
    plt.tight_layout(rect=[0, 0, 1, 0.99])
    plt.savefig(filename, dpi=300, bbox_inches="tight")
    print(f"Saved: {filename}", flush=True)
    plt.close(fig)


# -----------------------------
# Main
# -----------------------------
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Eigenvalue computation for collision operator matrices")
    parser.add_argument("--pkl", type=str, default=DEFAULT_MATRIX_FILE,
                        help=f"Path to pickle file (default: {DEFAULT_MATRIX_FILE})")
    args = parser.parse_args()
    MATRIX_FILE = args.pkl

    print("=== Loading matrix and computing eigenvectors ===", flush=True)
    print(f"Loading matrix from: {os.path.basename(MATRIX_FILE)}", flush=True)

    with open(MATRIX_FILE, "rb") as fp:
        Ma, meta = pickle.load(fp)

    Theta = float(meta.get("Theta", 0.0))
    w = np.clip(meta["w_active"].astype(np.float64), 1e-30, None)

    print(f"Matrix shape: {Ma.shape}, type: {type(Ma).__name__}", flush=True)
    print(f"Temperature (Theta): {Theta:.6g}", flush=True)
    print(f"Computing eigenfunctions for angular modes: {ms}", flush=True)
    print()

    # m-mode eigenfunctions
    eigenfunctions, eigenvalues, px, py = compute_eigenfunctions_by_mode(Ma, meta, ms=ms)

    # conservation diagnostics
    print_conservation_residuals(Ma, meta, px, py)

    print("=== Summary: angular-mode eigenvalues ===", flush=True)
    for m in ms:
        if eigenfunctions.get(m) is not None:
            print(f"m={m}: gamma={eigenvalues[m]:.6e}", flush=True)
        else:
            print(f"m={m}: No valid eigenfunction", flush=True)

    # plot by mode
    print()
    print("=== Creating eigenvector panel by angular mode ===", flush=True)
    plot_eigenvector_panel(eigenfunctions, eigenvalues, px, py, Theta, ms, w, plot_quantity=PLOT_QUANTITY_BY_MODE)

    # raw eigenvectors
    if COMPUTE_RAW_EIGENVECTORS:
        print()
        print(f"=== Computing raw eigenfunctions (no angular-mode projection, n_eigs={N_RAW_EIGS}) ===", flush=True)
        gammas_raw, vecs_raw, evals_sym_raw, res_raw, px_raw, py_raw = compute_general_eigenfunctions(Ma, meta, n_eigs=N_RAW_EIGS)

        print(f"Raw gammas (Rayleigh, first {min(10, len(gammas_raw))}):", gammas_raw[:min(10, len(gammas_raw))], flush=True)
        print(f"Raw residuals (first {min(10, len(res_raw))}):", res_raw[:min(10, len(res_raw))], flush=True)

        print()
        print(f"=== Creating raw eigenvector panel (plotting {N_RAW_PLOT} modes) ===", flush=True)
        # ---- PATCH: include the m-projected eigenvectors (the ones in M_Iee_...svg) into raw panel ----
        extra_items = []
        for m in ms:
            u = eigenfunctions.get(m)
            if u is None:
                continue
            extra_items.append((f"MODE m={m}", float(eigenvalues[m]), u))

        # ---- PATCH: compute best-match m for each raw eigenvector (helps correspondence) ----
        raw_matches = build_raw_matches_by_mode(eigenfunctions, vecs_raw, w)

        plot_general_eigenvector_panel(
            gammas_raw, vecs_raw, px_raw, py_raw, Theta, w,
            n_plot=N_RAW_PLOT,
            plot_quantity=PLOT_QUANTITY_RAW,
            extra_items=extra_items,
            raw_matches=raw_matches,
            filename="eigenvector_panel_raw.svg",
        )
    else:
        print()
        print("=== Skipping raw eigenvector computation (COMPUTE_RAW_EIGENVECTORS=False) ===", flush=True)