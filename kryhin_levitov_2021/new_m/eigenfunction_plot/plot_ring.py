# Integrals_eig_bruteforce.py
# Eigenvalue computation for matrices generated by Iee_matrix_bruteforce_generate.py
import os
import argparse
import numpy as np
import pickle
import threading
import time
from scipy.sparse import csr_matrix, diags
from scipy.sparse.linalg import eigsh, eigs
from matplotlib import pyplot as plt
# Use non-interactive backend for headless compute nodes (prevents blocking)
import matplotlib
matplotlib.use('Agg')  # Must be set before any pyplot calls

# Numba acceleration
USE_NUMBA = False
try:
    import numba
    from numba import njit
    USE_NUMBA = True
except ImportError as e:
    print("Numba import failed:", e)

if USE_NUMBA:
    # Optional diagnostics
    try:
        print("cpu_count:", os.cpu_count())
        print("numba threads:", numba.get_num_threads())
        print("numba layer:", numba.threading_layer())
    except Exception as e:
        print("Numba OK; diagnostics failed:", repr(e))

# Configuration
ms = [1]#[0, 1, 2, 3]#, 4, 5, 6, 7]  # angular modes to extract

# PATCH: allow radial structure in each angular mode (critical for T^4 odd-m asymptotics)
RADIAL_BASIS_K = 6          # number of radial powers (k=0..K-1); 6–10 usually enough
RADIAL_SIGMA_P_MULT = 3.0   # sets Gaussian envelope width in p around p=1
RADIAL_MODE_INDEX = 0       # which radial excitation to select (0=ground state, higher=more rings)

# Raw eigenvector computation settings (can be VERY slow for large matrices)
# WARNING: Raw eigenvector computation with which="SM" can take 5-15+ minutes for large matrices
# Set to False to skip entirely and speed up execution
COMPUTE_RAW_EIGENVECTORS = True   # Set False to skip raw eigenvector computation
N_RAW_EIGS = 1                     # Number of raw eigenvectors to compute (reduced for speed - SM is slow!)
N_RAW_PLOT = 1                     # Number of raw eigenvectors to plot (reduced for speed)

# PATCH: do NOT add an absolute diagonal regularization when chasing tiny low-T rates.
REG_ABS = 0.0

# Fixed pixel size (in points^2) for ring plots so squares touch / overlap slightly.
RING_PIXEL_SIZE = 20.0

plt.rcParams['text.usetex'] = False
plt.rcParams['font.family'] = 'serif'
plt.rcParams["legend.frameon"] = False

# Default file to analyze (can be overridden via --pkl argument)
DEFAULT_MATRIX_FILE = r"../M_Iee_nonparabolic_mu1_U10_N320_dp0.04626814_T0.1.pkl"

def build_centered_lattice(Nmax: int):
    """Build centered momentum lattice indices (same as in generator)."""
    half = Nmax // 2
    ns = np.arange(-half, half, dtype=np.int32)
    nx, ny = np.meshgrid(ns, ns, indexing="ij")
    nx = nx.reshape(-1)
    ny = ny.reshape(-1)
    return nx, ny, half


def reconstruct_px_py(meta):
    """Reconstruct px, py for active states from metadata."""
    Nmax = int(meta["Nmax"])
    dp = float(meta["dp"])
    half = int(meta["half"])
    shift_x = float(meta.get("shift_x", 0.0))
    shift_y = float(meta.get("shift_y", 0.0))
    active = meta["active"].astype(np.int32)
    
    # Reconstruct full lattice
    nx_full, ny_full, _ = build_centered_lattice(Nmax)
    
    # Get active states
    nx_active = nx_full[active]
    ny_active = ny_full[active]
    
    # Compute physical momenta
    px = dp * (nx_active.astype(np.float64) + shift_x)
    py = dp * (ny_active.astype(np.float64) + shift_y)
    
    return px, py


# Numba-accelerated core functions
if USE_NUMBA:
    @njit(cache=True, fastmath=True)
    def wdot_numba(u, v, w):
        """Weighted inner product: u^T W v (numba-accelerated)"""
        n = u.shape[0]
        result = 0.0
        for i in range(n):
            result += u[i] * w[i] * v[i]
        return result
    
    @njit(cache=True, fastmath=True)
    def wnorm_numba(u, w):
        """Weighted norm: ||u||_W (numba-accelerated)"""
        n = u.shape[0]
        result = 0.0
        for i in range(n):
            result += u[i] * w[i] * u[i]
        return np.sqrt(max(result, 0.0))
    
    @njit(cache=True, fastmath=True)
    def remove_projection_numba(u, q, w):
        """Remove projection of u onto q: result = u - <q,u>_W * q"""
        n = u.shape[0]
        # Compute <q, u>_W
        dot = 0.0
        for i in range(n):
            dot += q[i] * w[i] * u[i]
        # Create result array and subtract projection
        result = np.empty(n, dtype=np.float64)
        for i in range(n):
            result[i] = u[i] - dot * q[i]
        return result


def wdot(u, v, w):
    """Weighted inner product: u^T W v"""
    if USE_NUMBA:
        return wdot_numba(u, v, w)
    else:
        return float(np.dot(u, w * v))


def wnorm(u, w):
    """Weighted norm: ||u||_W"""
    if USE_NUMBA:
        return wnorm_numba(u, w)
    else:
        return np.sqrt(max(wdot(u, u, w), 0.0))


def w_orthonormalize(vecs, w, remove_basis=None):
    """W-orthonormalize a list of vectors, optionally removing projection onto a basis."""
    basis = []
    for v in vecs:
        u = v.astype(np.float64).copy()
        # Remove projection onto remove_basis if provided
        if remove_basis is not None:
            if USE_NUMBA:
                # Use numba-accelerated projection removal
                for q in remove_basis:
                    u = remove_projection_numba(u, q, w)
            else:
                for q in remove_basis:
                    u -= wdot(q, u, w) * q
        # Remove projection onto previous basis vectors
        if USE_NUMBA:
            # Use numba-accelerated projection removal
            for q in basis:
                u = remove_projection_numba(u, q, w)
        else:
            for q in basis:
                u -= wdot(q, u, w) * q
        # Normalize
        nrm = wnorm(u, w)
        if nrm > 1e-30:
            basis.append(u / nrm)
    return basis


class ProgressPrinter:
    """Thread-safe progress printer for long-running operations."""
    def __init__(self, message, interval=30, matrix_size=None, n_eigs=1):
        self.message = message
        self.interval = interval
        self.matrix_size = matrix_size
        self.n_eigs = n_eigs
        self.stop_flag = threading.Event()
        self.thread = None
        
        # Estimate typical runtime based on matrix size (heuristic)
        # For which="SM", typical times: 5k matrix ~2-5min, 10k ~5-15min, 20k ~15-30min
        if matrix_size is not None:
            if matrix_size < 5000:
                self.estimated_min, self.estimated_max = 120, 300  # 2-5 min
            elif matrix_size < 10000:
                self.estimated_min, self.estimated_max = 300, 900  # 5-15 min
            elif matrix_size < 20000:
                self.estimated_min, self.estimated_max = 900, 1800  # 15-30 min
            else:
                self.estimated_min, self.estimated_max = 1800, 3600  # 30-60 min
            # Adjust for number of eigenvalues
            self.estimated_min *= (1 + 0.3 * (n_eigs - 1))
            self.estimated_max *= (1 + 0.3 * (n_eigs - 1))
        else:
            self.estimated_min, self.estimated_max = None, None
    
    def _print_progress(self):
        start_time = time.time()
        iteration = 0
        while not self.stop_flag.is_set():
            elapsed = time.time() - start_time
            iteration += 1
            
            # Calculate estimated progress and time remaining
            if self.estimated_min is not None:
                # Use average of min/max as estimate
                estimated_avg = (self.estimated_min + self.estimated_max) / 2.0
                # Progress is based on elapsed vs estimated (capped at 95% since we don't know actual)
                progress_pct = min(95.0, 100.0 * elapsed / estimated_avg)
                
                # Estimate time remaining
                if elapsed < estimated_avg:
                    time_remaining = estimated_avg - elapsed
                    if time_remaining < 60:
                        time_str = f"{time_remaining:.0f}s"
                    elif time_remaining < 3600:
                        time_str = f"{time_remaining/60:.1f}min"
                    else:
                        time_str = f"{time_remaining/3600:.1f}hr"
                else:
                    time_str = "unknown (taking longer than typical)"
                
                elapsed_str = f"{elapsed/60:.1f}min" if elapsed >= 60 else f"{elapsed:.0f}s"
                print(f"  [PROGRESS] {self.message} | elapsed: {elapsed_str} | progress: ~{progress_pct:.1f}% | est. remaining: {time_str}", flush=True)
            else:
                elapsed_str = f"{elapsed/60:.1f}min" if elapsed >= 60 else f"{elapsed:.0f}s"
                print(f"  [PROGRESS] {self.message} | elapsed: {elapsed_str} | iteration {iteration}", flush=True)
            
            if self.stop_flag.wait(self.interval):
                break
    
    def start(self):
        self.thread = threading.Thread(target=self._print_progress, daemon=True)
        self.thread.start()
    
    def stop(self):
        self.stop_flag.set()
        if self.thread:
            self.thread.join(timeout=1.0)


def compute_general_eigenfunctions(Ma, meta, n_eigs=10):
    """
    Compute eigenvalues and eigenvectors of the collision operator
    without angular-mode projection.

    Solves the generalized eigenvalue problem:
        -M v = gamma W v,  W = diag(f(1-f)).

    Returns:
        vals: array of eigenvalues (decay rates)
        vecs: eigenvectors (columns)
        px, py: momentum coordinates for active states
    """
    print(f"  [compute_general_eigenfunctions] Starting, n_eigs={n_eigs}...", flush=True)
    
    # Get weight matrix W = diag(f(1-f)) from metadata
    w_active = meta["w_active"].astype(np.float64)
    w_safe = np.clip(w_active, 1e-30, None)  # Avoid zeros

    # Build weight matrix
    W = diags(w_safe, 0, format="csr")

    # Collision operator: -M v = gamma W v
    if isinstance(Ma, csr_matrix):
        A = -Ma
    else:
        A = csr_matrix(-Ma)

    n = A.shape[0]
    print(f"  [compute_general_eigenfunctions] Matrix size: {n}x{n}", flush=True)
    
    if REG_ABS > 0.0:
        A = A + diags([REG_ABS] * n, 0, format="csr")

    # Transform to symmetric problem: B = W^{-1/2} A W^{-1/2}
    print(f"  [compute_general_eigenfunctions] Transforming to symmetric form...", flush=True)
    w_inv_sqrt = 1.0 / np.sqrt(w_safe)
    Dinv_sqrt = diags(w_inv_sqrt, 0, format="csr")
    B = Dinv_sqrt @ A @ Dinv_sqrt

    # Check symmetry
    sym_err = np.abs((B - B.T).data).max() / (np.abs(B.data).max() + 1e-30) if B.nnz > 0 else 0.0

    n_eigs = min(n_eigs, max(n - 2, 1))
    
    # Use looser tolerance and fewer iterations for speed (especially for large matrices)
    # For large matrices, finding SM eigenvalues can be very slow
    tol_fast = 1e-6 if n > 10000 else 1e-8
    maxiter_fast = 5000 if n > 10000 else 20000

    if sym_err < 1e-8 and n_eigs > 0:
        # Use symmetric solver
        # For collision operators, we want eigenvalues closest to zero (slowest decay rates)
        # "SM" (smallest magnitude) is correct but can be very slow for large matrices
        # WARNING: This can take 5-15+ minutes for matrices > 10k
        print(f"  [compute_general_eigenfunctions] Solving with eigsh (which='SM', tol={tol_fast:.1e}, maxiter={maxiter_fast})...", flush=True)
        print(f"  [compute_general_eigenfunctions] WARNING: Finding smallest magnitude eigenvalues can take 5-15+ minutes for large matrices.", flush=True)
        print(f"  [compute_general_eigenfunctions] Please be patient or set COMPUTE_RAW_EIGENVECTORS=False to skip...", flush=True)
        try:
            # Start progress printer with matrix size for time estimation
            progress = ProgressPrinter("eigsh still running...", interval=30, matrix_size=n, n_eigs=n_eigs)
            progress.start()
            try:
                vals, y = eigsh(
                    B,
                    k=n_eigs,
                    which="SM",  # Smallest magnitude - finds eigenvalues closest to zero (slowest decay)
                    tol=tol_fast,
                    maxiter=maxiter_fast,
                )
            finally:
                progress.stop()
            vecs = (Dinv_sqrt @ y).astype(np.float64)
            print(f"  [compute_general_eigenfunctions] eigsh completed successfully", flush=True)
        except Exception as e:
            print(f"Warning: eigsh failed in general solver ({e}), falling back to eigs...", flush=True)
            try:
                # Try eigs without sigma first
                print(f"  [compute_general_eigenfunctions] Trying eigs (which='SM', tol={tol_fast:.1e}, maxiter={maxiter_fast})...", flush=True)
                progress = ProgressPrinter("eigs still running...", interval=30, matrix_size=n, n_eigs=n_eigs)
                progress.start()
                try:
                    vals, vecs = eigs(
                        A,
                        M=W,
                        k=n_eigs,
                        which="SM",  # Smallest magnitude - avoids shift-invert mode
                        tol=tol_fast,
                        maxiter=maxiter_fast,
                    )
                finally:
                    progress.stop()
                vals = np.real(vals)
                vecs = np.real(vecs)
                print(f"  [compute_general_eigenfunctions] eigs completed successfully", flush=True)
            except Exception as e2:
                print(f"Warning: eigs with which='SM' also failed ({e2}), trying with sigma as last resort...", flush=True)
                # Last resort: try with sigma, but this may fail with MemoryError
                vals, vecs = eigs(
                    A,
                    M=W,
                    k=n_eigs,
                    sigma=1e-10,
                    which="LM",
                    tol=tol_fast,
                    maxiter=maxiter_fast,
                )
                vals = np.real(vals)
                vecs = np.real(vecs)
    else:
        # Non-symmetric fallback
        print(f"Warning: Matrix not symmetric in general solver (error={sym_err:.3e}), using eigs", flush=True)
        try:
            # Try without sigma first to avoid memory issues
            print(f"  [compute_general_eigenfunctions] Solving with eigs (which='SM', tol={tol_fast:.1e}, maxiter={maxiter_fast})...", flush=True)
            progress = ProgressPrinter("eigs still running...", interval=30, matrix_size=n, n_eigs=n_eigs)
            progress.start()
            try:
                vals, vecs = eigs(
                    A,
                    M=W,
                    k=n_eigs,
                    which="SM",  # Smallest magnitude - avoids shift-invert mode
                    tol=tol_fast,
                    maxiter=maxiter_fast,
                )
            finally:
                progress.stop()
            vals = np.real(vals)
            vecs = np.real(vecs)
            print(f"  [compute_general_eigenfunctions] eigs completed successfully", flush=True)
        except Exception as e:
            print(f"Warning: eigs with which='SM' failed ({e}), trying with sigma as last resort...", flush=True)
            # Last resort: try with sigma, but this may fail with MemoryError
            vals, vecs = eigs(
                A,
                M=W,
                k=n_eigs,
                sigma=1e-10,
                which="LM",
                tol=tol_fast,
                maxiter=maxiter_fast,
            )
            vals = np.real(vals)
            vecs = np.real(vecs)

    # Ensure real
    vals = np.real(vals)
    vecs = np.real(vecs)

    # Sort by eigenvalue (ascending = slowest decay first)
    order = np.argsort(vals)
    vals = vals[order]
    vecs = vecs[:, order]

    # Normalize in W-norm: v^T W v = 1
    for i in range(vecs.shape[1]):
        v = vecs[:, i]
        wv = w_safe * v
        norm_w = np.sqrt(np.dot(v, wv))
        if norm_w > 1e-30:
            vecs[:, i] = v / norm_w

    # Reconstruct px, py
    print(f"  [compute_general_eigenfunctions] Reconstructing coordinates...", flush=True)
    px, py = reconstruct_px_py(meta)
    
    print(f"  [compute_general_eigenfunctions] Completed successfully", flush=True)
    return vals, vecs, px, py


def print_conservation_residuals(Ma, meta, px, py):
    """
    Print relative residuals for candidate conserved vectors to diagnose
    which combinations are (near) null modes of the collision operator.
    """
    w_active = meta["w_active"].astype(np.float64)
    w_safe = np.clip(w_active, 1e-30, None)

    # Collision operator A = -M in active space
    if isinstance(Ma, csr_matrix):
        A = -Ma
    else:
        A = csr_matrix(-Ma)

    ones = np.ones(A.shape[0], dtype=np.float64)

    cands = {
        "eta:1":   ones,
        "eta:px":  px,
        "eta:py":  py,
        "df:w":    w_safe,
        "df:wpx":  w_safe * px,
        "df:wpy":  w_safe * py,
    }

    scale = float(np.max(np.abs(A.data)) + 1e-30)

    print("\n=== Conservation residuals (relative) ===", flush=True)
    for name, v in cands.items():
        r = A.dot(v)
        num = np.linalg.norm(r)
        den = np.linalg.norm(v) * scale + 1e-30
        rel = num / den
        print(f"{name:8s}  rel_resid = {rel:.3e}", flush=True)
    print("=========================================\n", flush=True)


def extract_from_span(V, w, target):
    """
    From the column span of V, pick v closest to target in W-norm:
        v = argmin ||v - target||_W.
    Returns a W-normalized vector v.
    """
    if V.size == 0:
        return target / (wnorm(target, w) + 1e-300)

    # Gram matrix in W-inner product
    G = V.T @ (w[:, None] * V)
    b = V.T @ (w * target)
    coeff = np.linalg.solve(G, b)
    v = V @ coeff
    v /= (wnorm(v, w) + 1e-300)
    return v


def rayleigh_gamma(A, w, v):
    """
    Rayleigh quotient gamma = (v^T A v) / (v^T W v)
    for the generalized problem -M v = gamma W v.
    """
    Av = A.dot(v)
    num = float(np.dot(v, Av))
    den = float(np.dot(v, w * v)) + 1e-300
    return num / den


def compute_eigenfunctions_by_mode(Ma, meta, ms=[0, 1, 2, 3, 4, 5, 6, 7, 8]):
    """Compute eigenfunctions for specific angular modes m on the Fermi ring."""
    # Get weight matrix W = diag(f(1-f)) from metadata
    w_active = meta["w_active"].astype(np.float64)
    w_safe = np.clip(w_active, 1e-30, None)
    
    # Reconstruct px, py, and angles
    px, py = reconstruct_px_py(meta)
    theta = np.arctan2(py, px)
    P = np.sqrt(px * px + py * py)
    Theta = float(meta.get("Theta", 0.0))
    dp = float(meta.get("dp", 0.0))
    
    # Collision operator: -M v = gamma W v
    if isinstance(Ma, csr_matrix):
        A = -Ma
    elif isinstance(Ma, np.ndarray):
        if Ma.size > 1e8:
            print(f"  [warning] Large dense matrix ({Ma.shape}), converting to sparse...", flush=True)
            Ma_sparse = csr_matrix(Ma)
            A = -Ma_sparse
            del Ma_sparse
        else:
            A = csr_matrix(-Ma)
    else:
        A = csr_matrix(-Ma)
    
    W = diags(w_safe, 0, format="csr")
    
    # Add tiny regularization (if needed)
    n = A.shape[0]
    if REG_ABS > 0.0:
        A = A + diags([REG_ABS] * n, 0, format="csr")
    
    # Invariants: density and momentum
    inv_vecs = [np.ones(n, dtype=np.float64), px.copy(), py.copy()]
    
    # W-orthonormalize invariants (density + px + py)
    inv_orth = []
    for v in inv_vecs:
        v_norm = v.copy()
        # Remove projection onto previous invariants
        for q in inv_orth:
            proj = wdot(q, v_norm, w_safe)
            v_norm = v_norm - proj * q
        # Normalize
        nrm = np.sqrt(max(wdot(v_norm, v_norm, w_safe), 0.0))
        if nrm > 1e-30:
            v_norm = v_norm / nrm
            inv_orth.append(v_norm)
    
    eigenfunctions = {}
    eigenvalues = {}
    
    for m in ms:
        if m == 0:
            # m=0: constant mode (conserved density)
            u0 = inv_orth[0] if len(inv_orth) > 0 else np.ones(n, dtype=np.float64) / np.sqrt(n)
            eigenfunctions[m] = u0
            eigenvalues[m] = 0.0
            print(f"  [m={m}] density mode: gamma=0.0 (conserved)")
            continue
        
        if m <-1:#== 1:
            # m=1 *is* momentum conservation
            remove = inv_orth[:1] if len(inv_orth) > 0 else None
            U_list = w_orthonormalize([px.copy(), py.copy()], w_safe, remove_basis=remove)
        else:
            # For m>=2, allow radial structure (P-1)^k * cos/sin(mθ)
            remove = inv_orth[:1] if len(inv_orth) > 0 else None
            
            sigma_p = max(RADIAL_SIGMA_P_MULT * (0.5 * Theta), 4.0 * dp, 1e-12)
            z = (P - 1.0) / sigma_p
            g = np.exp(-0.5 * z * z)
            
            basis = []
            for kk in range(int(RADIAL_BASIS_K)):
                rk = (z ** kk)
                basis.append(g * rk * np.cos(m * theta))
                basis.append(g * rk * np.sin(m * theta))
            
            U_list = w_orthonormalize(basis, w_safe, remove_basis=remove)
        
        if len(U_list) == 0:
            print(f"  [m={m}] No valid basis, skipping")
            eigenfunctions[m] = None
            eigenvalues[m] = np.nan
            continue
        
        # Project operator onto basis: C = U^T A U
        U = np.column_stack(U_list)
        AU = A.dot(U)
        C = U.T @ AU
        C = 0.5 * (C + C.T)  # Symmetrize
        
        # Solve eigenvalue problem in basis
        evals, evecs = np.linalg.eigh(C)
        evals = np.real(evals)
        evals = evals[np.isfinite(evals) & (evals >= -1e-12)]
        
        if len(evals) == 0:
            print(f"  [m={m}] No valid eigenvalues")
            eigenfunctions[m] = None
            eigenvalues[m] = np.nan
            continue
        
        # Choose smallest non-negative eigenvalue (slowest decay in this subspace)
        j = np.argmin(np.maximum(evals, 0.0))
        gamma = float(max(evals[j], 0.0))
        u = U @ evecs[:, j]
        
        # Normalize in W-norm
        nrm = np.sqrt(max(wdot(u, u, w_safe), 0.0))
        if nrm > 1e-30:
            u = u / nrm
        
        # Optional: make m=1 plot stable by aligning with +px if it's that mode
        if m<-1: #== 1:
            px_proj = abs(wdot(u, px, w_safe))
            py_proj = abs(wdot(u, py, w_safe))
            if px_proj >= py_proj:
                u *= np.sign(wdot(u, px, w_safe) + 1e-300)
            else:
                u *= np.sign(wdot(u, py, w_safe) + 1e-300)
        
        eigenfunctions[m] = u
        eigenvalues[m] = gamma
        
        print(f"  [m={m}] gamma={gamma:.6e}")
    
    return eigenfunctions, eigenvalues, px, py


def ring_scatter(ax, px, py, val, title=""):
    """
    Render values on the (px,py) lattice as an image (imshow) with
    per-panel normalized colors and pixel-perfect squares, without gaps.
    """
    # Unique x,y coordinates define the lattice
    xs, ix = np.unique(px, return_inverse=True)
    ys, iy = np.unique(py, return_inverse=True)

    ny = len(ys)
    nx = len(xs)

    grid = np.full((ny, nx), np.nan, dtype=float)
    for k, (jx, jy) in enumerate(zip(ix, iy)):
        grid[jy, jx] = val[k]

    # Robust color limits, normalized per panel, ignoring NaNs
    if np.all(~np.isfinite(grid)):
        vmax = 1.0
    else:
        vmax = float(np.nanmax(np.abs(grid)))
        if vmax <= 0 or not np.isfinite(vmax):
            vmax = 1.0

    vmin = -vmax

    # Pixel edges in physical units
    if nx > 1:
        dx = float(np.min(np.diff(xs)))
    else:
        dx = 1.0
    if ny > 1:
        dy = float(np.min(np.diff(ys)))
    else:
        dy = 1.0

    extent = [
        xs[0] - dx / 2.0,
        xs[-1] + dx / 2.0,
        ys[0] - dy / 2.0,
        ys[-1] + dy / 2.0,
    ]

    cmap = plt.get_cmap("RdBu_r").copy()
    cmap.set_bad("white")

    im = ax.imshow(
        grid,
        origin="lower",
        cmap=cmap,
        vmin=vmin,
        vmax=vmax,
        extent=extent,
        interpolation="nearest",
        aspect="equal",
    )

    ax.set_title(title)
    ax.set_xticks([])
    ax.set_yticks([])
    return im


def plot_eigenvector_panel(eigenfunctions, eigenvalues, px, py, Theta, ms, w):
    """Plot eigenvectors as a panel of 2D plots in (px, py) space for each angular mode m."""
    # Filter out None eigenfunctions
    valid_ms = [m for m in ms if eigenfunctions.get(m) is not None]
    
    if len(valid_ms) == 0:
        print("No valid eigenfunctions to plot", flush=True)
        return
    
    # Create figure with subplots
    n_cols = 4
    n_rows = (len(valid_ms) + n_cols - 1) // n_cols
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(16, 4*n_rows))
    if not isinstance(axes, np.ndarray):
        axes = np.array([axes])
    else:
        axes = axes.flatten()
    
    last_sc = None

    for idx, m in enumerate(valid_ms):
        ax = axes[idx]
        v = eigenfunctions[m]
        gamma = eigenvalues[m]

        # Plot η * f(1-f) = v * w to match δf representation
        v_plot = v

        last_sc = ring_scatter(
            ax,
            px,
            py,
            v_plot,
            title=f"m={m},γ={gamma:.6e},Θ={Theta:.6g}",
        )
    
    # Hide unused subplots
    for idx in range(len(valid_ms), len(axes)):
        axes[idx].set_visible(False)
    
    plt.suptitle('Detected Eigenvectors for Angular Modes', fontsize=14, fontweight='bold', y=0.995)
    plt.tight_layout(rect=[0, 0, 1, 0.96])
    
    # Save figure
    fname = f'{MATRIX_FILE.replace(".pkl", "")}.svg'
    plt.savefig(fname, dpi=300, bbox_inches='tight')
    fname = f'{MATRIX_FILE.replace(".pkl", "")}.png'
    plt.savefig(fname, dpi=300, bbox_inches='tight')
    print(f"Saved: {fname}", flush=True)
    plt.close(fig)  # Close figure to free memory (no blocking plt.show() on headless nodes)


def plot_general_eigenvector_panel(vals, vecs, px, py, Theta, w, n_plot=10):
    """
    Plot raw eigenvectors (no angular projection) as a panel of 2D plots
    in (px, py) space.
    """
    if vecs.size == 0:
        print("No general eigenvectors to plot", flush=True)
        return

    n_vecs = min(n_plot, vecs.shape[1])

    # Create figure with subplots
    n_cols = 4
    n_rows = (n_vecs + n_cols - 1) // n_cols
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(16, 4 * n_rows))
    if not isinstance(axes, np.ndarray):
        axes = np.array([axes])
    else:
        axes = axes.flatten()

    last_sc = None

    for i in range(n_vecs):
        ax = axes[i]
        v = vecs[:, i]
        gamma = vals[i]

        # Plot η * f(1-f) = v * w
        v_plot = v

        last_sc = ring_scatter(
            ax,
            px,
            py,
            v_plot,
            title=f"mode #{i+1}, γ={gamma:.6e}, Θ={Theta:.6g}",
        )

    # Hide unused subplots
    for i in range(n_vecs, len(axes)):
        axes[i].set_visible(False)

    plt.suptitle("Raw eigenvectors (no angular-mode projection)", fontsize=14, fontweight="bold", y=0.995)
    plt.tight_layout(rect=[0, 0, 1, 0.99])

    fname = "eigenvector_panel_raw.svg"
    plt.savefig(fname, dpi=300, bbox_inches="tight")
    print(f"Saved: {fname}", flush=True)
    plt.close(fig)  # Close figure to free memory


def extract_and_plot_invariants_from_raw(Ma, meta, vals_raw, vecs_raw, px, py, w, Theta):
    """
    From the raw eigen-subspace, extract approximate density and momentum
    invariants and plot them as η * f(1-f).
    """
    if vecs_raw.size == 0:
        return

    # Build collision operator A = -M (same convention as elsewhere)
    if isinstance(Ma, csr_matrix):
        A = -Ma
    else:
        A = csr_matrix(-Ma)
    n = A.shape[0]
    if REG_ABS > 0.0:
        A = A + diags([REG_ABS] * n, 0, format="csr")

    ones = np.ones_like(px)

    # Use a modest number of lowest eigenvectors to span the near-null space
    # Reduced from 12 to 6 for speed (only need 3 invariants: density, px, py)
    # Need at least 3 eigenvectors for proper invariant extraction
    if vecs_raw.shape[1] < 3:
        print(f"Warning: Only {vecs_raw.shape[1]} raw eigenvector(s) available, skipping invariant extraction", flush=True)
        return
    k0 = min(6, vecs_raw.shape[1])
    V0 = vecs_raw[:, :k0]

    # Extract density mode
    v_rho = extract_from_span(V0, w, ones)

    # Make px, py orthogonal to density first, then extract
    px_ortho = px - wdot(v_rho, px, w) * v_rho
    py_ortho = py - wdot(v_rho, py, w) * v_rho

    v_px = extract_from_span(V0, w, px_ortho)
    v_py = extract_from_span(V0, w, py_ortho)

    # W-orthogonalize v_py against v_px
    v_py = v_py - wdot(v_px, v_py, w) * v_px
    v_py /= (wnorm(v_py, w) + 1e-300)

    # Rayleigh gammas
    gamma_rho = rayleigh_gamma(A, w, v_rho)
    gamma_px = rayleigh_gamma(A, w, v_px)
    gamma_py = rayleigh_gamma(A, w, v_py)

    print("=== Invariants extracted from raw eigenspace (Rayleigh gammas) ===", flush=True)
    print(f"rho: gamma = {gamma_rho:.6e}", flush=True)
    print(f"px : gamma = {gamma_px:.6e}", flush=True)
    print(f"py : gamma = {gamma_py:.6e}", flush=True)
    print("=================================================================", flush=True)

    # Quick overlaps to see mixing
    print("Overlaps of first few raw eigenvectors with 1, px, py (W-inner product):", flush=True)
    k_print = min(6, vecs_raw.shape[1])
    for i in range(k_print):
        vi = vecs_raw[:, i]
        o1 = wdot(vi, ones, w)
        opx = wdot(vi, px, w)
        opy = wdot(vi, py, w)
        print(f"mode {i:2d}: <v,1>_W={o1:+.3e}, <v,px>_W={opx:+.3e}, <v,py>_W={opy:+.3e}", flush=True)

    # Plot the three approximate invariants as η * f(1-f)
    fig, axes = plt.subplots(1, 3, figsize=(12, 4))
    labels = [("density (m=0)", v_rho), ("px (m=1,x)", v_px), ("py (m=1,y)", v_py)]

    for ax, (lab, v) in zip(axes, labels):
        v_plot = v
        ring_scatter(ax, px, py, v_plot, title=f"{lab}, Θ={Theta:.6g}")

    plt.suptitle("Approximate invariants from raw eigenspace (η·f(1-f))", fontsize=14, fontweight="bold", y=0.995)
    plt.tight_layout(rect=[0, 0, 1, 0.96])

    fname = "eigenvector_invariants_raw.svg"
    plt.savefig(fname, dpi=300, bbox_inches="tight")
    print(f"Saved: {fname}", flush=True)
    plt.close(fig)  # Close figure to free memory


if __name__ == "__main__":
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description='Eigenvalue computation for collision operator matrices')
    parser.add_argument('--pkl', type=str, default=DEFAULT_MATRIX_FILE,
                        help=f'Path to pickle file containing matrix and metadata (default: {DEFAULT_MATRIX_FILE})')
    args = parser.parse_args()
    
    MATRIX_FILE = args.pkl

    
    print("=== Loading matrix and computing eigenvectors ===", flush=True)
    
    # Load the specific matrix file
    print(f"Loading matrix from: {os.path.basename(MATRIX_FILE)}", flush=True)
    with open(MATRIX_FILE, 'rb') as fp:
        Ma, meta = pickle.load(fp)
    
    Theta = float(meta.get("Theta", 0.0))
    w_active_main = meta["w_active"].astype(np.float64)
    w_safe_main = np.clip(w_active_main, 1e-30, None)
    print(f"Matrix shape: {Ma.shape}, type: {type(Ma).__name__}", flush=True)
    print(f"Temperature (Theta): {Theta:.6g}", flush=True)
    print(f"Computing eigenfunctions for angular modes: {ms}", flush=True)
    print()
    
    # Compute eigenfunctions for angular modes
    eigenfunctions, eigenvalues, px, py = compute_eigenfunctions_by_mode(Ma, meta, ms=ms)

    # Diagnostics: check which candidate vectors are (near) conserved
    print_conservation_residuals(Ma, meta, px, py)

    print()
    print("=== Summary: angular-mode eigenvalues ===", flush=True)
    for m in ms:
        if eigenfunctions.get(m) is not None:
            print(f"m={m}: gamma={eigenvalues[m]:.6e}", flush=True)
        else:
            print(f"m={m}: No valid eigenfunction", flush=True)

    # Plot panel of detected eigenvectors (by angular mode)
    print()
    print("=== Creating eigenvector panel by angular mode ===", flush=True)
    plot_eigenvector_panel(eigenfunctions, eigenvalues, px, py, Theta, ms, w_safe_main)

    # Also compute and plot raw eigenvectors before angular-mode detection (optional, can be slow)
    if COMPUTE_RAW_EIGENVECTORS:
        print()
        print(f"=== Computing raw eigenfunctions (no angular-mode projection, n_eigs={N_RAW_EIGS}) ===", flush=True)
        vals_raw, vecs_raw, px_raw, py_raw = compute_general_eigenfunctions(Ma, meta, n_eigs=N_RAW_EIGS)

        print(f"Raw eigenvalues (first {min(10, len(vals_raw))}):", vals_raw[:min(10, len(vals_raw))], flush=True)

        print()
        print("=== Extracting and plotting invariant combinations from raw eigenspace ===", flush=True)
        extract_and_plot_invariants_from_raw(Ma, meta, vals_raw, vecs_raw, px_raw, py_raw, w_safe_main, Theta)

        print()
        print(f"=== Creating raw eigenvector panel (plotting {N_RAW_PLOT} modes) ===", flush=True)
        plot_general_eigenvector_panel(vals_raw, vecs_raw, px_raw, py_raw, Theta, w_safe_main, n_plot=N_RAW_PLOT)
    else:
        print()
        print("=== Skipping raw eigenvector computation (COMPUTE_RAW_EIGENVECTORS=False) ===", flush=True)
